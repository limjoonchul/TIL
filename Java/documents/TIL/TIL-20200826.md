# 오늘의 한 일
* fastCampus PreCourse 자바 기초 자바 프로그래밍부터 변수와 데이터 타입에 대해서
온라인 강의를 시청했다.
* 어제 하다가 마무리 못한 HomeworkDay6 Vector3D를 이어서 다시 풀어봤다.
* 학원 수업 내용과 precourse를 들으면서 똑같은 섹션에 대해서 따로 따로 정리를 할까
같이 묶어서 정리를 할까 고민을 계속하다가 결국 하나로 묶기로 했다 아직 다 정리하지 않아서
차근차근 정리를 해 나가야 한다.
* HomeworkDay7 Rect 구현을 하다가 다 구현하지 못했다. 내일 이어서 마무리하기.
* 블로그도 따로 만들 것인지, 아니면 그대로 github.io를 사용할 것인지 결정을 내려야 하고
그전까진 github.io에 계속 올릴 것이다.

# 프로그래밍 이란?
* 프로그래밍 : 컴퓨터에게 일을 시키기 위해 프로그래밍 언어로 만든 명령어,집합인 프로그램을 만드는 일
* 컴파일: 프로그래밍 언어를 기계어로 바꾸어 주는일
* 컴파일러 : 기계어로 바꾸어 주는 프로그램, 자바를 설치하면 자바 컴파일러도 설치 됨.
````markdown
자바를 설치를 하면 자바 라이브러리가 설치가되고 구동되는 환경도 설치되고 자바컴파일러도 설치됨
C,C++는 메모리를 직접 핸들링하는 특징들을 가지고 있었고, 이로 인해 프로그램이 비정상적으로
다운되는 일이 있었다 이렇게 되면 가정제품이나, 임베디드 소프트웨어들이 불안정하게 되서
동작을 멈추게 될 수 있음 그래서 더 안전된 언어가 필요했고 그런게 자바다.
처음에 임베디드소프트웨어를 만드는데 활용되다가 점차 영역이 넓어짐
````

## 다른 언어와의 차이점
* 플랫폼에 독립적인 프로그래밍을 할 수 있음

## 자바 프로그램의 특징
* 객체지향 프로그램으로 유지보수와 확장성이 좋고, 안정적이다.
* 풍부한 라이브러리가 제공되고 오픈소스와 연동된다.

## 왜 객체지향 프로그램을 해야 하는가?
* 재사용성이 용이하다 , 코드관리하기가 쉽다, 유지보수 용이, 신뢰성 높은 프로그램

## 자바로 만들 수 있는 프로그램
* 웹 서버, 모바일 앱, 게임

# 컴퓨터에서 사용하는 자료형
## 이진수 
* 비트 : 컴푸터에서 자료를 표현하는 최소 단위 0 또는 1
* 바이트 : 8bit
* 이진수 : 컴퓨터에서 표현되는 자료의 형태
           0000 1010(이진수) => 10(십진수)
* 8진수 : 이진수를 3비트씩 모아서 표현
* 16진수: 이진수를 4비트씩 모아서 표현

## 컴퓨터에서 음수 표현하기
* 2의 보수로 표현한다.
* 양수와 음수는 더해서 0이 되어야 하기 때문에
```markdown
0000 0101(5)
1111 1010(1의 보수)
1111 1011(5에 대한 2의보수)
5와 5에 대한 2의 보수를 더하면 0이 된다.
```
* 2의 보수를 만드는 방법(음수 만드는 방법) : 1의 보수를 취하고 나서 1을 더해준다.

```markdown
0000 1010 => 10
첫째 자리를 부호 비트라고 표현한다.
```

## 변수
* 변하는 수를 말한다. 사람의 나이, 온라인 상품의 개수, 학생의 학년
* 변하는 값을 프로그램에서 나타내기 위한 방법

## 변수 선언하기
* 자료형 변수 이름; int age;
* 변수에 맞는 자료형과 변수 이름으로 선언
* 변수를 선언만 할 수 있고, 선언과동시에 초기화할 수 있고 여러개도 한번에 선언할 수 있다.
* 값을 넣지 않고 출력을 하면 사용할 수 없게 표시됨.

## 변수와 메모리
* 변수를 선언하는 것은 해당 자료형의 크기 만큼의 메모리를 사용하겠다는 것
* 메모리의 위치를 변수 이름으로 참조
```markdown
변수를 선언한다는게 프로그래밍적으로 어떤 의미이냐 하면
int는 4바이트 인데, 4바이트 짜리 정수값을 써야 할때 int age; 선언한다.
메모리에 4바이트가 잡히고, 메모리를 사용할 때 변수를 사용하겠다는 의미이다.
변수의 사이즈에 맞는 적정한 메모리가 할당이 되고 메모리를 참조할 때 변수의 이름으로 참조한다.
```

# 자료형이란
 * 변수의 종류, 타입
 * 기본형(Primitiv Type):  자바 언어에서 기본적으로  제공해 주는 자료형,메모리의 크기가 정해져 있음 EX)정수형, 문자형, 실수형, 논리형
 * 참조형(Reference Type) : 클래스 자료형, JDK에서 제공되는 클래스와 프로그래머가 정의하는 클래스, 클래스에 따라 사용하는 크기가 다르다. EX) String, Student
 
 |     | 1byte | 2byte | 4byte | 8byte |
 |-----|-------| -----|----|------|
 | 정수형 |  byte| short| int | long |
 | 문자형 |      | char |     |      |
 | 실수형 |      |      | float | double |
 | 논리형 | boolean|    |       |        |
 
## 정수형 자료형
* long은 뒤에 L,l을 붙여줘서 8바이트로 사용하는 거라고 알려주는 것
* 원래는 기본 4바이트로 사용됨.

##문자 자료형

* 내부족으로는 비트의 조합으로 표현 
* 인코딩 - 각 문자에 따른 특정한 숫자 값( 코드값)을 부여
* 디코딩 - 숫자 값을 원래의 문자로 변환

### 문자 세트
* 문자세트 : 문자를 위한 코드 값 (숫자 값)들을 정해 놓은 세트
* 아스키(ASCII) : 1바이트로 영문자, 숫자, 특수문자 등을 표현 함
* 유니코드(Unicode) : 한글과 같은 복잡한 언어를 표현 하기 위한 표준 인코딩 ex) UTF-8, UTF-16
* 문자를 변수에 저장하면? 문자에 해당하는 코드 값이 저장 된다
* int val = 'A' 라 했을 때 65가 저장된다.

## 실수와 논리 자료형
* 실수는 double 자료형이 기분
* float를 사용할 때는 f, F 식별자를 사용한다.

* 실수는 부동 소수점 방식으로 표현
* 실수를 지수부와 가수부로 표현함
* 0.1을 표현하는 방식 1.0(가수) * 10(밑수)^-1(지수)

* float = 부호비트 + 지수부(8비트) + 가수부(23비트) 총32비트
* double = 부호비트 + 지수부(11비트) + 가수부(52비트)  총65비트

### 부동소수점방식
* 장점 아주 많은 범위를 실수를 표현할 수 있다
* 단점은 약간의 오차가 발생할 수 있음

### 부동 소수점 방식의 오류
* 지수와 가수로 표현되는 부동 소수 점은 0을 표현 할 수 없음
* 따라서 부동 소수점 방식에서는 약간의 오차가 발생할 수 있음

## 논리 자료형
* boolean 으로 선언
* 논리값 true(참), false(거짓)을 표현

* 자료형 없이 변수 사용하기(자바10)
* 지역 변수 자료형 추론(local vaiable type inference)
* 변수에 대입되는 값을 보고 컴파일러가 추론

## 상수와 리터럴
* 상수(constant) : 변하지 않는 수
* 리터럴(literal) : 프로그램에서 사용하는 모든 숫자, 값, 논리 값 ex)10,3.14,'A',true
* 모든 리터럴은 상수 풀(constant pool)에 저장되어 있음
* 상수 풀에 저장될 때 정수는 int, 실수는 double로 저장됨

## 형 변환
* 서로 다른 자료형의 값이 대입되는 경우 형 변환이 일어 남
* 묵시적 형 변환(implicit type conversion) : 작은 수에서 큰 수로 더 정밀한 수에서 더 정밀한 수로 대입되는 경우
```groovy
 int i = 1000;
 byte bNum = (byte)i;
 //데이터의 유실이 발생할 수 있다.
 System.out.println(bNum);

 double dNum1 = 1.2;
 float fNum = 0.9f;

 int iNum1 = (int)(dNum1 + fNum);
 int iNum2 = (int)dNum1 + (int)fNum;
 // 두개의 결과 값이 다름
```
* 명시적 형 변환(explict type conversion): 변환되는 자료 형을 몃이 자료의 손실이 발생할 수 있다
```groovy
 byte bNum = 10;
 int iNum = bNum;

 System.out.println(bNum);
 System.out.println(iNum);

 int iNum2 = 20;
 float fNum = iNum2;

 System.out.println(fNum);

 double dNum;
 dNum = fNum + iNum;
 System.out.println(dNum);
```