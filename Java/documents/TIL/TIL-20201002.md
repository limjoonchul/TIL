# 오늘 해야 할 일
* 람다식, 표준함수형 인터페이스, 스트림 복습하기
* 공격력 계산기 과제 풀어보기

# 오늘 한 일
* 람다식과 표준 함수형 인터페이스에 대한 유튜브 이것이 자바다의 강의를 보면서 복습했다.
* 복습한걸 블로그에 정리했다.

# 오늘 공부하면서 느낀 점
* 강의 하나당 시간이 너무 길다. 강의 하나가 3시간이나 되서 그거 보느라 오늘 다 보낸 것 같아..
스트림까지 복습하는게 목표였는데 못하고 그전까지 밖에 못했다. 주말이용해서 공부해야지 복습하면 익숙해지고
응용이 가능해 지겠지??

## 공부한 내용
### 람다식
 * 함수적 프로그래밍의 기법이다.
 
### 함수적 프로그래밍
  * y = f(x) 형태의 함수로 구성된 프로그래밍 기법 x에 어떤 값을 주면 y가 얻어지는 함수형 기법
     * 데이터를 매개값으로 전달하고 결과를 받는 코드들로 구성
     * 객체 지향 프로그래밍 보다는 효율적인 경우
        * 대용량 데이터의 처리시에 유리
             객체를  생성후 처리하는 것보다, 데이터를 바로 처리하는 것이 속도에 유리
        * 이벤트 지향 프로그래밍(이벤트가 발생하면 핸들러 함수 실행)에 적합
            반복적인 이벤트 처리는 핸들러 객체보다는 핸들러 함수가 적합
      * 현대적 프로그래밍 기법
        * 객체 지향 프로그래밍 + 함수적 프로그래밍
  
 
#### 자바 8부터 함수적 프로그래밍 지원
*  람다식을 언어차원에서 제공
*  (타입 매개변수) -> { 실행문 } == x -> y


### 자바에서 람다식을 수용한 이유
 * 코드가 매우 간결해진다,
 * 컬렉션 요소(대용량 데이터)를 필터링 또는 매핑해서 쉽게 집계할 수 있다.
 
### 자바는 람다식을 함수적 인터페이스의 익명 구현 객체로 취급한다.
 * 람다식은 매개변수를 가진 코드블록이다. -> 익명 구현 객체
 * 어떤 인터페이스를 구현할지는 대입되는 인터페이스에 달려있다.
 * 함수적 인터페이스는 한 개의 추상 메소드를 가지고 있는 인터페이스이다.
 
### 익명 구현 객체란
```groovy
 Runnable runnable  = new Runnable(){
      public void run(){ ... }
 }
 // 익명 구현 객체
 new Runnable(){
   public void run(){...} 
 }
```
* 이 부분이 익명 구현 객체이다.  이것과 똑같은 효과를 내게 하는 것이 람다식이다.
 
### 타켓 타입과 함수적 인터페이스
* 인터페이스(타켓 타입)  변수 = 람다식; 일때
* 람다식은 인터페이스의 익명 구현 객체가 된다
 
### 함수적 인터페이스
* 하나의 추상 메소드로 선언된 인터페이스만 타켓 타입이 될 수 있다
* @FuntionalInterface 어노테이션
    * 하나의 추상 메소드만을 가지는지 컴파일러가 체크하도록 한다.
    * 두 개 이상의 추상 메소드가 선언되어 있으면 컴파일 오류가 발생한다.
 
 
#### 매개변수가 있는 람다식
* MyFuntionalInterface fi = x-> { ... } 또는 (x) -> { ... }
* fi.method(5); 여기서 5는 x에 대입되어서 실행문에서 활용된다.
 
#### 리턴값이 있는 람다식
* MyFuntionalInterface fi = (x,y)-> { return 값; } 
* fi.method(2,5); 여기서 2,5는 x,y에 대입되어서 실행문에서 활용된다.
 
 
### 클래스 멤버와 로컬 변수 사용
* 클래스의 멤버 사용
   * 람다식 실행 블록에는 클래스의 멤버인 필드와 메소드를 제약없이 사용할 수 있다.
   * 람다식 실행 블록내에서 this는 람다식을 실행한 객체의 참조이다.
 
* 로컬 변수의 사용
    * 람다식은 함수적 인터페이스의 익명 구현 객체를 생성한다
    * 람다식에서 사용하는 외부 로컬 변수는 final 특성을 갖는다. 값을 변경할 수 없다.
 
## 표준 API의 함수형 인터페이스
* 자바 8부터 표준 API로 제공되는 함수형 인터페이스
   * java.util.function 패키지에 포함되어 있다.
   * 매개타입으로 사용되어 람다식을 매개값으로 대입할 수 있도록 해준다.

### Consumer
#### Consumer<T>
 * Consumer<String> consumer = t -> {t를 소비하는 실행문;};
 * <String>이므로 매개값 t는 String
 
#### BiConsumer<T,U>
 * BiConsumber<String,String> consumer = (t,u) -> t와 u를 소비하는 실행문;
 * <String,String> 이므로 매개값 t와 u는 모두 String 타입
 
#### DoubleConsumer
 * DoubleConsumer consumer = d -> d를 소비하는 실행문;
 * 매개값 d는 double타입 고정이다
 
#### ObjIntConsumber<T>
 * ObjIntConsumber<String> consumer = (t,i) - > t,i를 소비하는 실행문
 * t는 스트링 i는 int타입 고정
   
### Supplier 
* 외부로 데이터를 리턴해주는 역할을 한다.- getXXX() 메소드
### Funtion
* 매개값을 리턴값으로 매핑(타입변환)하는 역할을 한다.-applyXXXX() 메소드
   * Funtion<Student, String> funtion = t-> {return t.getName()};
      * <Student,String>이므로 매개값 t는 Student 타입이고 리턴 값은String 타입이다.
      * Student 객체를 String으로 매핑한 예제
   * ToIntFuntion<Student> funtion = t -> {return t.getScore();}
      * <Student> 이므로 매개값 t는 Student 타입이고 리턴값은 int 타입 고정.
      * Student 객체를 int로 매핑한 예제 
 
### Operator
* applyXXX()메소드를 가지고 있고 매개값을 리턴값으로 매핑하는 역할보다는
매개값을 이용해서 연산을 수행한 후 동일한 타입으로 리턴값을 제공하는 역할을 한다.
 
### Predicate 
* 매개변수와 boolean 리턴값이 있는 testXXX() 메소드를 가지고 있다.
 
 
### andThen()과 compose() 디폴트 메소드
* Consumer의 순차적 연결
  * Consumer 종류의 함수적 인터페이스는 처리 결과를 리턴하지 않기 때문에
    andThen()과 compose() 디폴트 메소드는 함수적인터페이스의 호출 순서만 정한다.
 
* Function의 순차적 연결
  * Function과 Operator 종류의 함수적 인터페이스는 먼저 실행한 함수적 인터페이스의
  결과를 다음 함수적 인터페이스의 매객밧으로 넘겨주고, 최종처리결과를 리턴한다.
 