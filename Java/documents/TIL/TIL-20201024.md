# 오늘 해야 할 일
* git에 알고리즘 푼 것들 정리해서 업로드 하기
* 알고리즘 한 문제 풀고, 내용 정리 해서 git이랑 블로그에 업로드하기
* 자바 스트림 부분 다시 강의 듣기 그리고 예제 문제 찾아서 연습하기
# 오늘 한 일
* 블로그에만 정리되어있던 알고리즘 문제 풀이 한것들을 깃에도 업로드 했다.
* 이것이 자바다 강의에서 스트림 부분을 다시 한 번 더 들었다. 마지막 병렬처리 부분 빼고 들었는데
생각보다 시간이 오래 걸려서 다 듣지 못하고, 알고리즘 문제도 풀지 못햇다.

# 오늘 공부 하면서 배운 점
## 자바 스트림 인강 다시 들으면서 정리!
### 매핑
* 매핑은 스트림의 요소를 다른 요소로 대체하는 것을 말한다.
하나의 요소가 꼭 하나의 요소로 매핑되는 것이 아니라, 여러 요소로 매핑될 수 있다.
#### flatMapXXX()메소드
* 한 개의 요소를 대체하는 복수개의 요소들로 구성된 새로운 스트림을 리턴한다.

| 리턴 타입 | 메소드(매개변수) | 요소 -> 대체 요소 |
| ------- | ------------- | -------- |
| Stream<R> | flatMap(Funtion<T, Stream<R>>) | T -> Stream<R> |
| DoubleStream | flatMap(DoubleFuntion<DoubleStream>) | double -> DoubleStream |
| DoubleStream | flatMapToDouble(Funtion<T,DoubleStream>) | T -> DoubleStream |

* 위 첫번째 줄처럼 되어있을 때 T는 입력으로 들오는 데이터의 타입이고, Stream<R>은 출력되는 데이터의 타입이다.
그래서 이 중간 연산의 리턴 타입이 Stream<R> 이 된다.
* 세번째 줄은 객체를 DoubleStream으로 매핑해주는 것이다.
   * 두번째 줄과 세번째 줄의 차이는 두번째는 double을 DoubleStream으로 매핑해주는 것이고,
   세번째는 객체를 DoubleStream으로 매핑해주는 것이다.

```groovy
List<String> inputList2 = Arrays.asList("10 20 30", "40 50 60"); // asList의 반환값이 ArrayList<>()로 되어있어서 이렇게 사용 가능!
  inputList2.stream()
          .flatMapToInt(data -> {
             String[] strArr = data.split(" ");
             int[] intArr = new int[strArr.length];
              for (int i = 0; i < strArr.length; i++) {
                  intArr[i] = Integer.parseInt(strArr[i].trim());
              }
              return Arrays.stream(intArr); // ()안에 int배열이 들어가면 stream()은 IntStream을 리턴한다.
          })
          .forEach(System.out::println);
```

#### mapXXX() 메소드
* 요소를 대체하는 요소로 구성된 새로운 스트림을 리턴한다.
```groovy
List<Student> studentList = Arrays.asList(
        new Student("홍길동",10),
        new Student("이순신",20),
        new Student("임꺽정",30)
);
studentList.stream()
        .map(student -> student.getName())
        .forEach(System.out::println);

System.out.println();
studentList.stream()
        .mapToInt(s -> s.getScore())
        .forEach(System.out::println);
```

#### asDoubleStream, asIntegerStream, boxed
```groovy
int[] intArray = {1,2,3,4,5};
   Arrays.stream(intArray) // 배열을 스트림으로 얻을 때 Arrays를 사용한다.
           .asDoubleStream() // 파라미터가 없어서 그대로 사용해서 출력하면됨
           .forEach(System.out::println);

   System.out.println();

   double[] doubleArr = {1.0,2.0,3.0,4.0,5.0};
   Arrays.stream(doubleArr)
           .boxed() // 각 스트림의 자료형에 따라 반환 타입이 변한다. int형을 넣으면 Intger, double을 넣으면 Double
           .forEach(System.out::println);
```

### 정렬
| 리턴 타입 | 매소드(매개변수) | 설명 |
| -------- | ------------ | ---- |
| Stream<T> | sorted() | 객체를 Comparable 구현 방법에 따라 정렬 |
| Stream<T> | sorted(Comparator<T>) | 객체를 주어진 Comparator에 따라 정렬 |
* 두개의 비교하는 인터페이스를 사용할 수 있었다! 헷갈렸는데 다시 보면서 정리됨
* 객체 요소일 경우(Stream<T>)에는 Comparable을 구현하지 않으면 첫번째 sorted() 메소드를 호출하면
ClassCastException이 발생한다.
* 그래서 객체 요소가 Comparable을 구현하지 않았거나, 구현 했다 하더라도 다른 비교 방법으로 정렬하려면
Comparator를 매개값으로 갖는 두번째 sorted() 메소드를 사용한다.

```groovy
   IntStream intStream = Arrays.stream(new int[]{5,3,2,1,4});
   intStream
        .sorted()
        .forEach(System.out::println);

   System.out.println();

   List<Student> studentList = Arrays.asList(
           new Student("홍길동",30),
           new Student("이순신",10),
           new Student("임꺽정",20)
   );

    studentList.stream()
           .sorted()
           forEach(student -> System.out.println(student.toString()));
    // Stduent클래스에 compare을 오버라이딩해서 score기준으로 정렬해서 숫자를 기준으로 정렬된다.

    System.out.println();

    studentList.stream()
          .sorted(Comparator.reverseOrder())
          .forEach(student -> System.out.println(student.toString()));

    System.out.println();

    studentList.stream()
          .sorted((o1, o2) -> o1.getName().compareTo(o2.getName()))
          .forEach(student -> System.out.println(student.getName()));
```

## 루핑
* 중간 도는 최종 처리 기능으로 요소 전체를 반복하는 것을 말한다.

### peek() 중간 처리 메소드
* 최종 처리 메소드가 실행되지 않으면 지연되기 때문에 최종 처리 메소드가 호출되어야만 동작한다.
```groovy
int[] intArr = {1,2,3,4,5};
System.out.println("peek()를 마지막에 호출한 경우");
Arrays.stream(intArr)
        .filter(num -> num%2==0)
        .peek(System.out::println);
// 동작하지 않는다.

System.out.println("최종처리 메소드를 마지막에 호출한 경우");
int result = Arrays.stream(intArr)
        .filter(num -> num%2==0)
        .peek(System.out::println)
        .sum();

System.out.println(result);
```

### forEach() 최종 처리 메소드
```groovy
System.out.println("forEach() 메소드를 마지막에 호출한 경우");
        Arrays.stream(intArr)
                .filter(num -> num%2==0)
                .forEach(System.out::println);
```

## 매칭(matching)
* 최종 처리 기능으로 요소들이 특정 조건을 만족하는지 조사하는 것을 말한다.
### allMatch()
* 모든 요소들이 매개값으로 주어진 Predicate의 조건을 만족하는지 조사
### anyMatch()
* 최소한 한 개의 요소가 매개값으로 주어진 Predicate의 조건을 만족하는지 조사
### nonMatch()
* 모든 요소들이 매개값으로 주어진 Predicate의 조건을 만족하지 않는지 조사
```groovy
        int[] intArr = {2,4,6};
        boolean result = Arrays.stream(intArr)
                .allMatch(value -> value%2==0);
        System.out.println(result);
        // 모두 조건식과 맞아야 true반환

        boolean result1 = Arrays.stream(intArr)
                .anyMatch(value -> value%2==0);
        System.out.println(result1);
        // 하나라도 조건식에 맞으면 true 반환


        boolean result2 = Arrays.stream(intArr)
                .noneMatch(value -> value%2==0);
        System.out.println(result2);
        // 조건식과 맞는게 하나도 없을 때 true 반환
```

## 집계(Aggregate)
* 최종 처리 기능
   * 카운팅, 합계, 평균값, 최대값, 최소값 등과 같이 하나의 값으로 산출한다.
   * 대량의 데이터를 가공해서 축소하는 리덕션이라고 볼 수 잇다.
   
| 리턴 타입 | 메소드(매개변수) | 설명 |
| -------- | ------------ | ----- |
| long | count | 요소 개수 |
| OptinalXXX | findFirst() | 첫번째 요소 |
| Optional<T> | max(Comparator <T>) | 최대 요소 |
| OptionalXXX | max() | |
| Optional<T> | min(Comparator <T>) | 최소 요소 |
| OptionalXXX | min() | |
| OptionalDouble | average() | 요소 평균 |
| int, long, double | sum() | 요소 총합 |

* sum() 만 빼고 다 Optinal클래스를 반환한다.


### OptionalXXX클래스
* 자바 8부터 추가된 값을 저장하는 값 기반 클래스
  * java.util 패키지의 Optinal, OptionalDouble, OptionalInt, OptionalLong 클래스를 말한다.
  * 저장된 값을 얻으려면 get(). getAsDouble(), getAsInt(), getAsLong()를 호출한다.
      * 이 메소드들을 사용하면 Optinal로 감싸져 있는 값을 벗겨서 반환하는 것이다. 
      * ex) OptinlalDdouble형태면 .getAsDouble()하면 double값이 반환 됌!
      
  * 집계 메소드의 리턴 타입으로 사용되어 집계 값을 가지고 있다.
* 특징
  * 집계 값이 존재하지 않을 경우 디폴트 값을 설정할 수도 있다.
  * 집계 값을 처리하는 Consumer를 등록할 수 있다.
  
| 리턴타입 | 메소드(매개변수) | 설명 |
| ------- | ------------ | ---- |
| boolean | isPresent() | 값이 저장되어 있는지 여부 |
| T | orElse(T) | 값이 저장되어 있지 않을 경우 디폴트값 |
| double | orElse(double) | |
| int | orElse(int) | |
| long | orElse(long) | | 
| void | isPresent(Consumer) | 값이 저장되어 있을 경우 Consumer에서 처리 |
| | isPresent(DoubleConsumer) | |
| | isPresent(IntConsumer) | |
| | isPresent(LongConsumer) | |

### 커스텀 집계
####  reduce() 메소드
* sum(), min(), max() 이외에 특정한 값을 집계하기 위해서 사용한다.

| 인터페이스 | 리턴 타입 | 메소드(매개변수) |
| -------- | -------- | ------------- |
| Stream | Optional<T> | reduce(BinaryOperator<T> accumulator) |
| Stream | T | reduce(T identity, BinaryOperator<T> accumulator) |
| IntStream | OptionalInt | reduce(IntBinaryOperator op) |
| IntStream | int | reduce(int identity, IntBinaryOperator op |
| LongStream | OptionalLong | reduce(LongBinaryOperator op) |
| LongStream | long | reduce(Long identity, LongBinaryOperator op |
| DoubleStream | OptionalDouble | reduce(DoubleBinaryOperator op) |
| DoubleStream | double | reduce(double identity, DoubleBinaryOperator op |

* 각 스트림별로 reduec 메소드가 두개씩 존재한다.
   * 위 아래 reduce 메소드의 차이점은
   * 위에꺼는 연산의 결과가 있다면 연산의 값을 반환하고, 없다면 예외가 발생한다!!!
   * 아래꺼는 연산의 결과가 없다면, 디폴트로 identity값을 반환한다.
      * 연산의 결과가 없다는 것은 요소가 없는 경우이다!! 

* 매개변수
   * XXXBinaryOperator : 두 개의 매개값을 받아 연산 후 리턴하는 함수적 인터페이스
   * identity : 스트림에 요소가 전혀 없을 경우 리턴될 디폴트 값

## 수집 - Collect()
* 최종 처리 기능으로 요소들을 수집 또는 그룹핑한다.
  * 스트림소스(컬렉션, 배열, 파일 등)을 스트림을 만들어서 요소들을 하나씩 가져와서 필요한 경우에 필터링 또는 매핑을 해서
  최종적으로 얻은 요소들을 가지고 새로운 컬렉션을 생성하는 것을 수집이라 한다.
  * 스트림소스(컬렉션, 배열, 파일 등)을 오리지널 스트림을 만들어서 스트림의 요소를 그룹핑을 해서
  그룹핑된 것을 집계하는 기능도 collect()가 제공한다.
 
### 필터링한 요소 수집 
* 수집을 하기 전에 필터링을 한다. 오리지널 스트림에서 필요한 요소만 필터링을해서 별도의 컬렉션을 만든다.

| 리턴 타입 | 메소드(매개변수) | 인터페이스 |
| -------- | ------------ | --------- |
| R | collect(Collector<T,A,R> collector) | Stream |

* Collector가 요소를 어떤 컬렉션에 수집할 것인지를 결정한다.
* Collector의 타입 파라미터
   * T : 요소 
   * A : 누적기
   * R : 요소가 저장될 새로운 컬렉션
   // 요소를 누적기가 컬렉션에 저장한다.

* Collector의 구현 객체
  * Collectors 클래스의 정적 메소드를 이용해서 Collector의 객체를 얻어 낼 수 있다.
 
 | 리턴 타입 | 메소드 | 설명 |
 | -------- | ----- | --- |
 | Collector<T,?,Collection<T>> |   Collectors.toCollection{Supplier<T>} |   Supplier가 제공한 Collection에 저장 |
 | Collector<T,?,ConcurrentMap<K,U>> |    Collectors.toConcurrentMap(...)  | ConcurrentMap에 저장한다. |                       
 | Collector<T,?,List<T>> |   Collectors.toList()    |  List에 저장 |
 | Collector<T,?,Map<K,U>> |   Collectors.toMap() |  Map에 저장 |
 | Collecotr<T,?,Set<T>> |  Collectors.toSet()    |   Set에 저장 |
 
 * 멀티쓰레드 환경에서 쓰레드의 안전한 concurrentmap을 만들어서 거기에 요소를 수집하는 Collector를 얻는다.
 * collect() 메소드 안에 Collector<T,A,R> collector 부분에 Collectors.toList() 이것들을 넣어주면 각각의 컬렉션들이 반환된다.
 * 누적기가 ?인 이유는
    * 알려져있는 컬렉션의 경우에는 Collector 내부에서 이 컬력센들을 저장하는 방법을 알고 있기 때문에
    별도의 누적기가 필요하지 않다.
    
### 사용자 정의 컨테이너에 수집하기
* List, Set, Map에 수집하는 것이 아니라 사용자 정의 컨테이너에 수집시키는 것을 말한다.
    * 사용자 정의 컨테이너란 개발자가 작성한 클래스를 의미한다.

| 인터페이스 | 리턴 타입 | 메소드(매개변수) |
| -------- | -------- | ------------ |
| Steam | R | collect(Supplier<R>, BiConsumer<R,?,super T>, BiConsumer<R,R>) |
| IntSteam | R | collect(Supplier<R>, ObjIntConsumer<R>, BiConsumer<R,R>) |
| LongSteam | R | collect(Supplier<R>, ObjLongConsumer<R>, BiConsumer<R,R>) |
| DoubleSteam | R | collect(Supplier<R>, ObjDoubleConsumer<R>, BiConsumer<R,R>) |

#### 매개변수
 * 첫번째 Supplier : 요소들이 수집될 컨테이너 객체를 생성하는 역할(= 사용자 정의 컨테이너를 만드는 역할)
   * 순차 처리(싱글 스레드) 스트림 : 단 한 번 Supplier 가 실행
   * 병렬 처리(멀티 스레드) 스트림 : 스레드별로 Supplier가 실행되어 스레드별로 컨테이너가 생성

* 두번째 XXXConsumer : (Supplier가 만든)컨테이너 객체에 요소를 수집하는 역할
   * 스트링에서 요소를 컨테이너에 누적할 때마다 실행

* 세번째 BiConsumer : 컨테이너 객체를 결한하는 역할
   * 순차 처리(싱글 스레드) 스트림 : 실행되지 않음 (사용하지 않더라도 객체는 만들어 줘야한다.)
   * 병렬 처리(멀티 스레드) 스트림 : 스레드별로 생성된 컨테이너를 결합해서 최종 컨테이너를 완성한다.

#### 리턴타입
* R 최종 누적된 컨테이너 객체


## 요소를 그룹핑해서 수집
* collect()메소드는 단순히 요소를 수집하는 기능 이외에 컬렉션의 요소들을 그룹핑해서 Map객체로 생성하는
기능도 제공
   * Collectors.groupingBy()의 리턴 객체를 매개값으로 대입
     * 스레드에 안전하지 않는 Map 생성 싱글 스레드 환경에서 사용
   * Collectors.groupingByConcurrent()의 리턴 객체를 매개값으로 대입
     * 스레드에 안전한 ConcurrentMap 생성  멀티스레드 환경에서 사용

* groupingBy(Function<T,K> classifier) : Function에 따라 키가 결정이 된다.
요소를 어떤 키에 저장할 것인지를 정의한다.

* groupingBy(Function<T,K> classifier, Collector<T,A,D> downStream) 
  * 예를 들어 남학생 객체를 저장한다했을 때 객체 자체를 저장하는게 아니라, 남학생의 이름, 성별등의 요소만 저장하는 것이다.
  * 이런 요소들을 저장하는 정보는 두번째 매개값인 Collector에서준다. 그래서 매핑된 내용(남학생 -> 남학생 이름)이 들어간다.
```groovy
 Map<Student.City,List<String>> mapByCity = list.stream()
                .collect(Collectors.groupingBy(Student::getCity,
                        Collectors.mapping(Student::getName,Collectors.toList())));
                         // 학생객체를 이름으로 매핑할 것이니깐  mapping(k,v) 이름 기준으로 list를 값을 넣는다.
// Student로부터 이름을 얻어서 이름을 List에 저장을 해서 컬렉터를 만드는 메소드를 사용한 것이다.
// 결국 이 메소드에의해서 리턴되는 컬렉터가 들어감으로써 학생이름이 매핑되어 들어간다.  
```
* groupingBy(Function<T,K> classifier, Supplier<Map<K,D>> mapFactory, Collector<T,A,D> downStream)
  * 위에 메소드와 차이는 위에꺼는 자동적으로 만들어진 객체를 사용하고, 이건 두번째 Supplier가 제공해주는 Map을 사용한다.
   
* 학생의 성을 키로 해서 남학생 List와 여학생 List가 저장된 Map 얻기
   * groupingBy(Function<T,K> classifier) 사용


## 그룹핑 후 매핑 및 집계
 * Collectors.groupingBy() 메소드는 그룹핑 후,
   매핑이나 집계(평균, 카운팅, 연결, 최대, 최소, 합계)을 할 수 있도록 하기 위해
   두번째 매개값으로 다음과 같은 Collector를 가질 수 있다.

| 리턴 타입 | 메소드(매개변수) | 설명 |
| Collector | Collectors.mapping(Function,Collecotr) | 매핑 |
| Collector | Collectors.averagingDouble(ToDoubleFunction) | 평균값 |
| Collector | Collectors.counting() | 요소수 |
| Collector | Collectors.joining(...) | 문자 요소들을 연결 |
| Collector | Collectors.maxBy(Comparator) | 최대값 |
| Collector | Collectors.minBy(Comparator) | 최소값 |
| Collector | Collectors.reducing(...) | 커스텀 리덕션 값 |
| Collector | Collectors.summarizingXXX(ToXXXFunction) | XXX 타입의 합계 |

