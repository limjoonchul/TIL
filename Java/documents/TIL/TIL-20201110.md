# Today I Learned!
## 오늘의 공부 계획
* 강사님이 알려준 레퍼런스에서 HTTP부분 읽으면서 공부, TCP/UDP 각 각 공부하고 차이점 알아두기
* OSI 7 layer 공부하기
* OAuth2 공부하기

## 오늘의 공부 내용
* 신재용강사님이 어제의 수업 내용에 대해서 다시 한번 쭉 설명을 해주셨다. 설명을 들은 내용을 정리했다.
* OAuth에 대해서 블로그에 정리된 내용들을 읽어봤다.
* 쿠키 세션에 대한 유튜브 강의를 찾아보고 개념에 대해 공부했다.

## 오늘 공부 하면서 배운 점 정리
* 이제 진짜 백엔드로 시작인데 첫 시작부터 꼬였다. 배워야 할건 많은데 공부 외적으로 신경을 써야하는 부분이 생겨서
그래도 뭔가를 알아야할게 많아서 공부를 뭘 해야할지 고민하지 않아도 되는 것 같긴하다... 어떻게 해야 효율적으로 할 수 있는지가 
더 중요해지는 것 같다. 일단 필요한 기본적인 개념부터 차근차근 알아가도록 공부하자.
### HTTP
* HTTP(HyperText Transfer Protocol) - 클라이언트와 서버간의 데이터를 주고 받을 수 있는 통싱 규약.
* HTTP 메세지 - 클라이언트의 요청을 서버에서 응답할 때 응답에 대한 정보를 클라이언트로 보낼때 정보가 담긴
메세지를 의미한다. 시작줄, 헤더, 본문으로 구성 되어있다.
* 요청
  * 시작줄 - 메소드 주소 버전으로 구성되었다.
  * 헤더 - 요청에 대한 정보를 담고 있다.
  * 본문 - 요청을 할 때 함께 보낼 데이터를 담고 있다.
* 응답
  * 시작줄 - 버전 상태코드 상태메세지로 구성
  * 헤더 - 응답에 대한 정보
  * 본문 - 요청한 데이터를 담아서 보내는데 HTML이 담겨있어서 브라우저가 이걸 받아 화면에 렌더링 한다.

* HTTP 메서드
  * GET, POST, PUT, PATCH, DELETE 가 있다.
  * GET - 서버로부터 데이터를 가져올 때 사용
  * POST - 클라이언트가 서버에 데이터를 새로 추가할 때 사용 
  * PUT - 서버에 이미 존재하는 데이터를 업데이트할 때 사용
  * DELETE - 서버의 데이터를 삭제할 때 사용.
  * GET과 DELTE를 제외한 나머지는 요청을 보낼 때 본문을 같이 보낼 수 있다.
  * OPTIONS - 서버가 어떤 메서드를 지원하는지 알아볼 때 사용 (CORS문제에 많이 나온다)
     * 실제 요청을 보내기전 서버를 테스트해보는 용도
* HTTP 헤더 
* 공통 헤더 - 요청과 응답 모두에 사용되는 헤더
  * Date - HTTP 메세지가 만들어진 시각이다.
  * Connection - 해당 요청이 끝난 후에 클라이언트와 서버가 계속해서 네트워크 커넥션을 유지할 것인지를 지시하는 부분
    * Keep-alive : 유지. cancle : 끊기
  * Cache-Control
  * Content-Length - 요청과 응답 메세지의 본문 크기를 바이트 단위로 표시해준다. 메세지 크기에 따라 자동으로 만들어진다.
  * Content-Type - 컨텐츠의 타입 과 문자열 인코딩을 명시한다.
  * Content-Language - 사용자의 언어를 뜻한다.
  * Content-Encoding - 컨텐츠 압축된 방식, 응답 콘텐츠를 br, gzip, deflate등의 알고리즘으로 압축해서 보내면
  브라우저가 알아서 해제해서 사용한다.
* 요청 헤더
  * Host - 서버의 도메인 네임이 나타나는 부분 (포트 포함), 요청한 서버의 Host
     * `Host: www.naver.com`
     * 반드시 하나가 존재 해야 한다.
  * User-Agent - 현재 사용자가 어떤 운영체제와 브라우저를 이용해서 요청을 보냈는지 나온다.
  * Accept - 요청을 보낼 때 서버에 이런 타입(MIME)의 데이터를 보내줬으면 좋겠다고 명시할 때 사용
  공통 헤더의 Content와 대응된다.
    * Accept-Charset - 문자 인코딩을 명시
    * Accept-Language - 원하는 언어를 명시
    * Accept-Encoding - 원하는 콘텐츠 압축 방식
  * Authorization - 인증 토큰을 서버로 보낼 때 사용하는 헤더
  * Origin - POST같은 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지를 나타낸다.
  요청을 보낸 주소와 받는 주소가 다르면 CORS문제가 발생한다.
  * Referer - 이전페이지의 주소가 담겨 있다 이헤더를 사용하면 어떤 페이지에서 지금 페이지로 들어왔는지
  알 수 있다.
* 응답 헤더
  * Access-Control-Allow-Origin(CORS라고도 한다.)
    * 요청주소와 받는주소가 같은지를 확인하는 헤더인 것 같다 다르면 CORS가 발생한다.
  * Allow - 요청을 받는 메소드를 지정하는 것 같다.
  * Content-Disposition - 응답 본문을 브라우저가 어떻게 표시해야 할지 알려주는 헤더
    * inline - 웹페이지 화면에 표시,  attachment - 다운로드 된다.
  * Loaction - 300번 때나 201 Created 응답일 때 어느 페이지로 이동할지를 알려주는 헤더
  * Content-Security-Policy - 다른 외부 파일들을 불러오는 경우, 차단할 소스와 불러올 소스를 여기에 명시할 수 있다.
     * self로 지정하면 자신의 도메인 파일만 가져온다.
     * https는 https를 통해서만 파일을 가져올 수 있다.
     * none은 파이를 가져올 수 없다.
* 캐시
  * 브라우저에 응답으로온 HTML이나 JSON같은 데이터가 저장되어 나중에 서버에 요청을 보내지 않고도 브라우저에 저장된 응답을 사용할 수 있다.
  * 보통 캐싱은 GET 요청에만 한다. GET이 REST적 가져오다라는 의미이기 때문에, 가져온 데이터를 저장해두고 쓰는 것이다.
  * Cache-Control
    * `Cache-Control: no-store` - 아무것도 캐싱하지 않을 때 사용
    * `Cache-Control: no-cache` - 버에 캐시 가져다 써도 되냐를 물어봐서, 가져다 써도 된다고 하면 캐시를 쓰고, 
    안 된다고 하면 새로 컨텐츠를 내려받는 옵션입니다.
    * `Cache-Control: must-revalidate` - 만료된 캐시만 서버에 확인을 받도록 하는 것
    * `Cache-Control: public 또는 private` - public이면 공유 캐시에 저장해도 된다라는 뜻이고, private이면 브라우저 같은 특정 상요자 환경에만 저장하라는 뜻
    * `Cache-Control: public, max-age=3600` - max-age로 캐시 유효시간을 줄일 수 있다.
* 쿠키 
  * 브라우저에 저장되는 작은 데이터 조각으로, 임시 데이터 보관 또는 웹 페이지 개인화 등에 사용된다.
   
출처 : https://www.zerocho.com/category/HTTP/post/5b4c4e3efc5052001b4f519b

## 세션 로그인 유지 방식
### 기본적인 세션 유지 방식
* 웹사이트에 로그인할 때 로그인이 유지되는 것
* 클라이언트에서 서버로 요청을 보낸다  아이디와 비밀번호를 보낸다.
* 그럼 서버에서 해쉬펑션을 돌려서 내부데이터베이스와 매칭이되면 로그인이 성공이되면  서버에서 세션을 만든다.
* 세션에는 세션아이디,  유저아이디 타임아웃 권한 이만들어진다. 그런 후에 쿠키에 세션아이디를 담아서 응답을 해주는 것이다.
* 그러면 클라이언트에 로그인이 이루어졌을 때 접속된 화면이라던지 이런게 보여질 것이고,
그 후에 클라이언트에서 메일보기같은 요청을 다시 보낸다면 이 쿠키가 담겨서 요청이 보내진다
* 이 쿠키에 담긴 세션아이디가 서버상에 세션이 있다면 그 세션에 대한 정보들을 가지고 있으니 그 사용자의 메일함으로 이동이 되는 응답을 보내줄 것이다.
없을 때는 로그인하지 않은 정보를 보내준다. io가 상당히 높은 작업이된다.
### 트래픽이 증가했을 대
* 그래서 많은 웹서버에서 내부에 ram이라는 공간에 db형식으로 저장을 해놓는다.
* 웹서버의 트래픽이 많아진다면 서버하나로 감당이 안되니깐 1,2,3 서버를 만들고 클라이언트와 중간에 로드밸러서를 둔다.
* 클라이언트가 로그인할 때 로드밸런서가 서버1로 매칭시켜준다음에 세션아이디를 담은 응답을 해주면
* 이 클라이언트 쿠키에는 세션아이디가 있게된 상태가 된다.
* 그 다음에 다시 다른 요청을 보낼 때 로드밸런서가 서버 2로 매칭을 시켜준다고 하면 이 클라이언트 쿠키는
서버 2에서 찾을 수가 없는 문제가 생긴다. 그러면 클라이언트는 로그아웃된 페이지를 보게 된다.
* 이런 걸 방지하기 위해서 로드밸런서는 한 클라이언트에는 한 서버로만 접속을 하게 하는 테크닉이 필요하다.
* 그래서 세션전용 데이터베이스를 만든다 그러면 이 각각의 서버는 클라이언트가 어떠한 서버로 요청을 해도
각각의 서버는 이 세션전용 데이터베이스에서 매칭을 시켜주기 때문에 올바른 응답을 줄 수 있다. 
   
* 여기서 더 나아가서  모든 트래픽이 하나의 데이터베이스에 몰리게 되는 문제가 생기는데
그래서 분산으로 데이터베이스를 만들어서  세션1~1000까지는 DB1 1000~2000까지는 DB2에 저장하는
복잡한 시스템을 만들어가야한다 그래서 해결하기 위한 방법이 token based authentication 대부분 jwt이다.  