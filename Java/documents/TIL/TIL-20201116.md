# Today I Learned!
## 오늘의 공부 계획!
* 인프런 Spring 강의 6개 듣고, 내용 정리해서 깃에 업로드하기
* 학원 스프링 강의 잘 듣고, 내용 잘 정리하기
## 오늘 공부한 내용
* 인프런 Spring강의를 6개 다 들었다. 들으면서 깃에 내용 정리한 부분을 추가해서 업로드했다.
* 오늘부터 저녁 6시~10시에 학원 강의가 진행되었다. 다형성, jdbc에 대해서 들었다.
## 오늘 공부 하면서 배운 것 요약 정리 및 생각
### 인프런 스프링 강의  
* @SpringBootTest - 스프링 컨테이너와 테스트를 함께 실행한다.
* @Transactional - 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에
항상 롤백한다. 이렇게 하면 DB에 데이터가 남기지 않으므로 다음 테스트에 영향을 주지 않는다.
서비스에 붙으면 정상적으로 작동하는데 테스트에 사용할 때만 롤백한다.
* spring.jpa.hibernate.ddl-auto=none
   * jpa는 객체를 보고 테이블을 다 만들어서 지금은 만들어져 있기 때문에 이 기능을 끄는 것이다.
* JPA는 EntityManger로 모든 동작을 한다. 
* build.gralde에 implementation 'org.springframework.boot:spring-boot-starter-data-jpa' 이걸해서 라이브러리를 다운받으면
스프링부트가 알아서 데이터베이스와 연결을 다해서 EntityManger를 생성해준다. 그래서 이 만들어준걸 인젝션 받으면 된다.

### 학원 스프링 강의
#### 다형성
* 디폴트 생성자가 하는 역할
* 원래 생성자의 역할은 객체가생성이될대 멤버변수의 값을 의미잇는값으로 초기화할 때 사용
* 프리미티브 타입은 그 타입의 디폴트 값으로 초기화가 되고, 레퍼런스 타입은 null로 초기화가 된다.
* 디폴트 생성자는 매개변수가 없는 생성자.
* 생성자가 없다고 해서 디폴트 생성자가 아니라 멤버변수를 디폴트로 초기화 할 수밖에없어서 이렇게 부른다.

* 삼성티비와 엘지티비를 따로 만들었을때 다형성을 적용하지 않은 상태에서 개발자한테 맡기면 마음대로 클래스를 만들더라
* 삼성티비와 엘지티비의 메소드를 강제할 수 있는 수단이 없기 때문에 각각 다른 메소드로 만든다면 호출할 때 다 뜯어고쳐야한다.

* 삼성티비를 쓰다가 엘지티비로 바꾸면 일일히 메소드호출을 바꿔줘야해서 다형성을 적용해야한다.
* 다형성을 잘이해하고있어야 서블릿 스프링할 때 수월하다.

#### 프로그램의 개발 발전
* 프로그램 개발 발전은 복사/붙여넣기로 시작이 되었다. 반복되는 코드들을 복사붙여넣기하니깐 너무많아 유지보수가 어려워서 생긴게
* 함수가 생김 함수를 기반으로 절차지향언어 c가 생김 반복적으로 사용하는 코드를 함수로 모듈화 시켜놓으면 그 코드가 필요하면 함수만 호출하면되니깐
* 반복되는 코드를 줄여나가게 되었고. 알고리즘만 재사용하니깐 재사용성이 좋아지면 좋겠다 해서 나온게 클래스이다.
* 클래스는 단순히 함수만 있는게 아니라 함수가 동작할 때 필요한 변수까지 가지고 있어서 재사용성이 점점 좋아지는 쪽으로 발전함.

* 클래스를 통째로 바꿔치기하면서 재사용을 하려면 다형성이라는게 필요하다! 그래서 객체지향언어의 핵심은 다형성이다.
* 다형성을사용하지않을꺼면 복잡한 객체지향언어를 사용할 필요가 없다.

* 다형성을 사용했더니 클라이언트가 소스수정이 필요하다 그래서 이 다형성을 한단계 뛰어넘는게 디자인패턴인다.
* 팩토리패턴을 사용하면 공장으로붙어 원하는 것을 얻어낸다. 클라이언트는 유지보수과정에서 수정되지 않는다.
* 클라이언트(main)만 봐서는 무슨 tv가 생성되는지 알수 없다. 클라이언트는 이렇게 작성되어야 한다.

* 구글 티비를 만들어서 그냥 프로그램 컨피규레이션에 google을 넣는다고 동작하지않음 빈팩토리에 분기를 만들어서 조건을 걸어줘야 동작이 된다.
* 소스르수정하면 컴파일다시해야하고 컴파일다시하면 서버에 다시 올려야한다. 소스수정을 최소화시키는 방향으로 생각해야한다.
* 다형성, 디자인패턴를 써도 해결되지 않은 문제를 해결하는 것이 스프링프레임워크이다. *핵심은 유지보수할 때 자바소스를 안건드리는 것이다. 그래서 컴파일을 다시 할 필요가 없다.

#### JDBC
* jdbc:h2:tcp://localhost/~/test - 원격으로 접속할 수 있게 url을 바꿈
* DDL
```roomsql
drop table board;
create table board(
 seq number(5) primary key,
 title varchar2(200),
 writer varchar2(200),
 content varchar2(200),
regdate date default sysdate,
cnt int(5) default 0
);
```

* 데이터베이스가 달라졌을 때 sql은 db에 맞게수정해야함 커넥션도 db에 따라 다를 수 밖에없음.
* 나머지 자바코드는 db와 상관없이 재사용 가능하다.

* db연동할 때 java.sql 패키지 클래스나 인터페이스를 이용해야한다.
* 인터페이스가 훨씬 많다. 인터페이스가 많다는건 jdbc도 내부적으로 다형성을 이용하고 있다라고 알면 된다.
* 특정 db에 비 종속적인 자바코드를 유지할 수 있다.

* jdbc api - java.sql 패키지  인터페이스가 많음(리모콘) 이 인터페이스를 구현한게 jdbc driver이다
* 이 드라이버는 db 개발자들이 개발한다 최적화된 자바코드를 이용해서 개발한다.
* 그래서 드라이버는 db에 따라 달라질 수 있고 성능이 달라질 수 있다.

* 우리가 드라이버를 개발하는게 아니다그런데  여러 db가  동일한 인터페이스를 인터페이스했기 때문에 똑같은 메소드를 가지고 있다.

* InsertBoardTest 클래스에 드라이버를 연결할 때 java.sql(jdbc interface, 리모콘)패키지 을 이용했다.
* 그럼 구현 클래스들이 동작을한다. 이런걸 드라이버라한다 db벤더 개발자들이 드라이버를 개발한다.
* 클라이언트가 tv유저 리모콘이라는 인터페이스를 통해서 오라클, mysql jdbc 드라이버인 lgtv, samsungtv가 동작한다.

* 클라이언트에서 sql이 dbms에 전송되도록 하는 것인데 jdbc interface가 중요하다
* 이 인터페이스를 driver라는 클래스가 구현하고 있다 db마다 다르다.

* jar파일을 등록을해주면 인터페이스에 대한 구현클래스들을 확보하는 것이다(드라이버)

* 드라이버매니저를 통해 특정 드라이버를 메모리에 올려야한다.
* 우린 h2 드라이버를 메모리 로딩해야한다 그래야 이 드라이버로부터 연결을 얻을 수 있고 연결로부터 스테이트먼트 클래스를 얻을 수 있다.
* jar파일 안에서 org.h2 driver.class가 중요하다. new org.h2.Driver()를 등록한다.

#### 참고
* zulu jdk를 알아둬라 오라클 jdk는 기능이 몇개 막혀있어서 오픈jdk를 쓰는데 이건 바로바로 업데이트가 되지 않음
오픈 jdk를 커스텀마이징해서 자동으로 업데이트하게 나온게 zulu jdk이다. (azul.com 에서 다운로드 가능)