# Today I Learned!
## 오늘의 공부 계획
* 어제 배운 HTTP, Servlet 내용 정리해서 깃에 업로드하기
* 서블릿 정리한 내용 복습하고, 블로그도 찾아보면서 동작 순서 등 확실히 이해하기 
## 오늘 공부한 내용
* HTTP, Servlet 수업 나갔더 내용들을 깃에 정리해서 업로드했다.
* 배운 내용을 읽어보고 블로그 찾아보고 하면서 헷갈렸던 라이프사이클에서 어떤식으로 동작이 되었는지에 대해서 배운 내용을 토대로는 이해가 확실히 되었다.
* Servlet으로 게시판 만드는 수업을 진행했다 내용 정리 및 복습은 내일하자!

## 오늘 공부 하면서 배운 점 및 생각 정리
* 모르는 것이 생기면 스스로 찾아보려고 하는 노력이 부족한 것 같다. 주위 잘하는 사람에게 물어볼려고 하는 습관이 계속나오는 것 같다.
모르는 것이 생기면 일단 혼자서 열심히 찾아보고, 정 찾기 힘들거나 너무 어려운 개념에 대해서 물어보도록 하자. 이런 모르는 걸 찾는 능력도 결국 하나의 실력의 일부분이 되니깐.
### Servlet
* 톰캣은 자바 클래스로 되어있는 웹 어플리케이션 서버이다.
* 서블릿은 클래스이고 톰캣에 의해서만 동작이 가능하다.

* 처음 실행시킬 때 전체적인 서블릿의 실행 과정을 정리해보면
 1. 실행 버튼을 누르면 `Tomcat tomcat = new Tomcat()` 해서 톰캣 객체가 생성된다.
 2. 톰캣에 의해서 `new ServletEngine()`이 실행된다. 이때 서블릿 엔진에는 web.xml을 매개변수로 들어가서 로딩이 된다, 스레드 풀도 생성된다.
 3. 이 상태까지가 서버가 작동되는 과정이였고, 이 상태로 기다리고 있게 된다.
    * 원래 실제 웹 어플리케이션을 이용할 때는 서버가 이미 올라가 있는 상태에서 사용을 한다
 4. 그러다가 브라우저에서 요청이 오면(ex-/hello.do) 서블릿 엔진에서 web.xml을 이용해서 해당하는 요청이 메모리에 있는지 확인한다.
 5. 메모리에 없으면 요청과 매핑된 hello.Servlet 찾아서 메모리에 올린다.
 6. 생성자가 호출이 된다(객체가 생성이 된 것, 부모 클래스들도 생성이 된다). 이때 생성자는 디폴트 생성자만 호출이 되어진다. 매개변수가 있는 생성자는 호출이 안됨, 매개변수 생성자만 있는경우 에러가 뜸.
 7. 다음 int()를 호출하는데 init()는 디폴트 생성자가 호출이되서 서블릿 객체가 메모리에 뜨기 때문에 멤버 번수를 단 한번 초기화할 때 필요하다.
 8. 스레드 풀에서 스레드가 랜덤으로 할당되어서 스레드는 run()메소드를 실행하는데 이 run()은  service()를 호출하도록 구현이 되어 있다.
 9. service()가 오버라이딩이 되어있지 않으면 내부적으로 요청방식이 get/ post이냐에 따라서 doGet() 또는 doPost()를 호출한다.
 9. doGet() 또는 doPost()이 실행되어서 기능을 수행한다.
 10. 그런 다음 반환 값을 응답으로 클라이언트에게 보내주게 된다. 끝!
 
* 두번 째 부터는 이미 서블릿이 메모리에 로딩이 되어있기 때문에 같은 서블릿의 요청이 오면 8번부터 실행이 되어서 동작이 이루어진다.
* 서블릿 객체는 서버가 종료되어서 서블릿 엔진이 종료되고 할 때 메모리에서 내려오고, destroy() 메소드가 실행되어서 자원을 회수하고 메모리에서 내려오게 된다.
  * 서버를 재 구동하거나 종료될 때 이렇게 실행되도록 구현이 되어있다.

### HTTP
* 클라이언트에서 서버쪽으로 요청할 수 있는 방법이 3 가지가 있다.
  * URL 입력을 통한 요청, 버튼, 링크
#### HTTP 통신 과정
* 클라이언트에서 서버로 URL로 GET 방식으로 요청을 하면 요청 프로콜을 만들어서 요청을 하게 된다.
* 시작 라인, 메세지 헤더, 메세지 바디로 구성이 되어 있다. (메세지 헤더와 바디는 CRLF 빈 줄로 나누어져 있다.)
   * 시작 라인 - 요청 방식(Get, Post) , URI , 프로토콜 버전(근데 이건 거의 바뀌지 않음)
   * 메세지 헤더 - 어떤 형태로 전송을 할 것인가, 길이, 캐쉬연결, 클라이언트 정보 등등이 담겨져 전송되는데 이건 브라우저마다 다 다르다.
   * 메세지 바디 - GET방식일 때는 여기에 아무것도 작성이 되지 않고, POST일 때만 요청이 담겨져 전송된다.
* 서버는 기다리고 있다가 요청이 오면 요청 프로토콜을 분석한다. 요청 방식이 뭐고, 어떤 형태로 전송 요청이 왔고.. 등등 을 파악한다.
* 요청에 해당하는 자료를 찾아서 응답 프로토콜에 담아서 클라이언트로 보내주게 된다.
* 응답 프로토콜도 요청 프로토콜과 구조는 비슷하다.
  * 시작 라인 - 프로토콜 버전, 응답 상태 코드, 응답 상태 코드의 메세지
  * 메세지 헤더 - 요청한 자료를 어떤 형태로 보내는지 이건 요청한 헤더와 맞아야 한다. 그런 정보들을 담고 있다. 종류가 되게 많음.
  * 메세지 바디 - 여기에 요청한 자료가 html이였으면 html 형태의 자료가 작성되어있고, json 등등 의 형태에 따라 다르게 작성되어서 전송된다.
* 그럼 클라이언트가 응답 프로토콜을 받아서 렌더링하게 된다.
* 중요 응답 상태 코드
  * 200 - 전송이 잘 되었을 때 뜬다.
  * 404  - 요청한 파일을 찾을 수 없을 때 또는 url패턴 매핑이 안되어 있을 때 뜬다.
  * 405 - 요청한 method가 없을 때  요청한방식이 post로 요청했는데 post가 없고 get밖에 없을 때 뜬다. 
  * 500 - 서버오류 예외가 발생하면 그 아래 코드는 실행되지 않는다. 이런 상황일 때  