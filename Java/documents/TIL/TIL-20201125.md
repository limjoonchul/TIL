# 오늘의 공부 계획
* Spring IoC, DI에 대한 내용들 git에 정리해서 업로드하기
* 강의 때 실습했던 부분들 인텔리제이로 다시 구현해보기
* 오늘 수업 나갈 AoP 에 대한 내용들 찾아보면서 예습하기

# 오늘 공부한 내용
* IoC, DI 수업했던 내용 정리해서 git에 업로드 했다.
* 인텔리제이로 실습해볼려 했는데 설정하는데 오래 걸릴 것 같아서 일단 이클립스에 새로운 프로젝트를 만들어서 실습해봤다.

# 오늘 공부하면서 배운 점 및 생각
```xml
<bean id="tv" class="pholymorphism4.LGTv">
      <constructor-arg  ref="speaker"></constructor-arg>
      <constructor-arg value="13000"></constructor-arg>
</bean>
<bean id="speaker" class="pholymorphism4.AppleSpeaker"></bean>
```
* 참조되는 값만 가져오는 것이라서 bean등록 순서가 바뀌어도 상관없다.
그런데 메모리에 먼저 올라가는건 speaker가 먼저 올라간다 엘지티비를 생성하여 참조할 때 소니스피커가 필요하니깐  먼저 생성되도록 되어있는건가?


```xml
<bean id="speaker" class="pholymorphism4.SonySpeaker"></bean>
<bean id="tv" class="pholymorphism4.LGTv">
	<property name="speaker" ref="speaker"></property>
	<property name="price" value="12222"></property>
</bean> 
```
* property의 name= "XXX"는 LGTv 클래스에 있는 setXXX 메소드의이름과 매핑된 것을 찾아가는 것 같다.
setSpeaker의 매개변수로 들어가는 값을 매핑하는 줄알았는데 setSpeaker 자체를 매핑해준다.


```xml
<context:component-scan base-package="pholymorphism4"></context:component-scan>
```
* 컴포넌트 스캔을 썼을때  pholymorphism4 패키지의 클래스 명순서대로 구성되어있는데 이 순서대로 메모리에 로딩된다.

### set 설정
```xml
<bean id="boardDAO" class="com.rubypapper.biz.board.BoardDAO"></bean>
<bean id="boardService" class="com.rubypapper.biz.board.BoardServiceImpl">
	<property name="boardDAO", ref="boardDAO"></property>	      
</bean>
```
### ioc의 개념을 설명 
* 제어의 역전 역제어라고 한다. 
* 반대말로는 순제어 객체의 생성과 관리의 주도권을 개발자가 가지고 있는것
* 자바소스로 생성하고 제어하는 것을 자바소스로 구현을 하는 것
* 단점은 유지보수가 어렵다 생성되는 객체를 바꿀려면 자바소스를 수정해야 하니깐
* 이 ioc를 적용하면 컨테이너가 두가지를 제어한다.
  1. 객체 생성 xml에 등록된 객체를 생성한다.
  2. 객체와 객체간의 의존관계도 관리한다.
* 컨테이너가 제어하니깐 xml만 수정하면 된다.
* 결국 오브젝트에 대한 제어를 컨테이너가 담당하는 것이 ioc(역제어)라고 한다.
* 또 중요한 개념은 객체들을 할당하라고 지시할려면 xml에 작성을해서 이걸 통해서 컨테이너가 객체를 생성하고 객체와객체관계를 정의한다.
xml을 통해 컨테이너를 제어할 수 있다.
* 디펜던시 룩업은 전혀 중요하지 ㅇ낳음,, 클라이언트 프로그램에서 컨테이너가 실행될 때 xml을 로딩했을 때 객체들이 떠있을 때 tv인 객체를 검색해달라고 하는게 룩업이다.

### DI
* 디펜던시 인젝션 생성자 인젝션 세터인젝션으로 나뉜다.
* 원래는 디폴트 생성자만  인식하지만 생성자 알규먼트로 참조값을 넘기면 객체를 확인해서 객체를 넘겨준다. 
* `Construct-arg`가 없으면 디폴트 생성자 있으면 매개변수를 가진 생성자이다.

* 새터인젝션 삼성티비를 디폴트 생성자로 생성하고 name="speaker"라고 되어 있으면
setSpeaker를 생성하라는 것이고 삼성티비를 생성할 때 이 소니스피커를 넘겨라
* 세터인젝션만 사용하는 이유는 생성자인젝셔는 변수가 맣으면 많을수록 생성자를 여러개 만들어야 하는데 세터인젝션은 세터메소드만 만들어 두면  되니깐 

* p네임스페이스는 p:speaker-ref="sony" 속성으로 처리할 수 잇는 차이 일뿐 property랑 똑같다.

### 어노테이션
* 스프링 설정파일에 새로운 네임스페이스를 설정하는것은 이네임스페이스에 속하는 다른종류의 태그를 사용할 수 있다는 의미이다. 다른 종류의 작업을 요청할 수 있다.
* base-package안에 있는 객체들중 컴포넌트가 있는 객체들을 찾아서 메모리에 띄운다.
* 프로그램을 쉽게 할려면 내가 지정하는 id를 지정해서 사용하는게 좋다.

* 타입인젝션이라고 부른 이유 컨테이너야 메모리에서 이 타입의 객체를 찾아라
* 이객체가 있기만 하다면 자동으로 할당해라 라고 해서 타입인젝션이라고 부른다.

### 에러 메세지 보는법 
* 프레임워크를 이용해서 개발하면 어려운게 자바파일을 만든적업슨ㄴ 파일들에서
* 에러 메세지들이 뜬다. 이 클래스들이 다 아키텍쳐에 해당하는 골격에 해당하는 클래스들인데 내가 만들지 않았던 것들이라 어렵다. 그래서 스프링이어렵고 디버깅이 어렵다.

* 맨밑에 있는 에러를 보면 된다. 문제의 근원 위로갈 수록 추상적인 에러이고 밑으로갈 수록 구체적인 에러이다.
* 마지막 예외를 보고 설명을보면 이해가 된다.

* 소니에 컴포넌트를 없애고 엘지에서 아우터와이어드를 소니로 했을 때 메모리에 올라가 있는 소니 객체가 없다고 노서치파일예외가 뜬다.
* 빈등록을 해도 되지만, 해당 클래스 에 컴포넌트 에노테이션이 있으면 xml등록을 안해도 메모리에 올라가니 이 방법이 더 편하다
* 소니스피커를 애플스피커로 변경하려고할 때 자바소스를 수정하게 되는데 이러면 안된다.
* 컴파일을 다시 해야한다. 스프링의 목적은 자바소스를 수정 안하는 것이다.
* 인터페이스 타입으로 하면 된다. 그런데 소니스피커애플스피커를 둘다 컴포넌트로 해두면 어떤 객체를 할당해야하는지 컨테이너에서 헷갈려서 에러가난다.

* 그래서 컴포넌트를 하나는 막고 하나는 풀어두고 또 바꾸면 다른하나는 풀고 다른 하나는 묵고 이러는 방식도 자바소스를 수정하는 방법이니 좋은 방법이 아니다. 이문제를 해결방법은?
* 애플과 소니에 컴포넌트를 지우고 xml에  실제로 사용할 Speaker 타입의 객체를 하나만 빈으로 등록한다. 
 `<bean class="pholymorphism4.SonySpeaker"></bean>`
* 여기서 중요한 개념은 어노테이션을 지원하는 이유가 엄청많아질 xml 코드를 최소화하는 것이지 xml을 없애는게 아니다. 모든걸 어노테이션으로 하는건 불가능하다.
그래서 xml과 어노테이션을 같이 사용하는 것이다.

*  내가 만들지 않은 라이브러리로 지원되는 클래스는 어노테잇녀을 적용할 수 없기 때문에 빈으로 등록하는 방법밖에 없다.

* 내가 만든 클라스라도 유지보수과정에서 객체 변환이 안바뀌는 것은 에노테이션을 하고, 자주 바뀌는것은 빈으로 등록한다.

* `@Resource`는  스프링 기반으로 만든 전자정부프레임워크는 오토와이어드대신 리소스를 사용한다.
* 똑같은데 차이점 리소스는 name속성을 사용할 수 있어서 두가지를 확인한다
* 해당 객체가 name이랑 같은 객체인지 오토와이어드만 알고 있으면 된다.

* 역제어를 이용하면 xml을 수정하면 다시 로딩하면 된다. 그래서 자바 파일은 다시 컴파일할 필요가없다.