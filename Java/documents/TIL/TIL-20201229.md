# 오늘의 공부 계획
* 오전에 어제 수업 내용 복습하기
* 오후 자료구조/알고리즘 수업 듣기
* 저녁 스프링 심화 수업 듣기 
# 오늘 공부한 내용
* 수업 내용 복습
* 알고리즘/ 자료 구조 수업들으면서 정리

# 오늘 공부하면서 배운 점 및 생각
## 자료구조 / 알고리즘

* 자료구조와 알고리즘을 선택하는 것이 중요하다.
이런 자료구조와 알고리즘을 써야 알 수 있어야 실제로 구현할 수 있기 때문에
키워드를 뽑아내는 것이 핵심이다.

### 자료구조

* 자료 - 현실세계로부터 수집한 사실이나 개념의 값 또는 이들의 집합
* 특정 용도로 사용하기 위해 가공한 것을 정보라고 한다.

* 학생들이 받은 점수 수집한 사실/ IQ, EQ같은 것도 개념적인 값
A,B반이 받은 점수들 전체도 데이터라고 부른다.

* A,B반의 각각의 평균을 내서 어느 반이 더 평균이 높다고 나온든데
평균을 이렇게 어떤 용도로사용하기 위해서 가공한 것을 정보라고 한다.
* 데이터는 가치관없이 단순히 취득된 것
* 정보는 특정한 목적, 가치관을 가지고 계산되고 비교되는 것

* 자료구조 - 자료들의 모임, 관계, 자료들에 적용할 수 있는 함수나 명령
1번학생도 97점일수 있고 5번학생도 97점일 수 있는데
각각의 학생들이 점수를 순서를 정의함으로써 관계를 정의할 수 있다.

* 부모의 모근이 100K 자식들도 모근 100K, 10K를 가지고 있는데
이런 부모 자식관계가 새롭게 발생한 것이다.
여기서 100K자식이 또 아들을 낳아서 1000K의 모근을 갖고
10K자식은 0K 모근을 갖는다.

* 화가나서 10K인 아들을 자료구조에서 삭제를 하면 0K 손자는 부모를 잃고 고아 상태가 된다.
부모와 자식이 있는관계에서 부모없는 자식이 있을 수 없기 때문에
할아버지가 손자를 직접 자식관계를 맺는다. 성공적으로 10K를 삭제 하는 것이다.

* 순서가 있는건 삭제해도 똑같이 순서를 이루지만
트리 자료구조는 중간에 자료가사라지면 중간을 매꾸기위한 특별한
동작이 필요하다. 사이드 이팩트를 없애기 위해서 추가작업이 필요함..
특정 함수나 명령, 자료구조가 어떻게 관계를 맺고있는지 특별한 함수나 명령
메소드를 같이 배우게 된다?

### 자료구조의 특징
* 이런것들을 고려해서 설계되어야 한다.

* 효율성 - 자료구조가 만능이 아니기 때문에 특정한 상황에서 효율성이 좋아야 한다.
모든 상황에서 좋은 자료구조는 없다. 특정한 상황에서는 효율성이 좋아야한다.

* 추상화 - 인터페이스를 사용하듯이 추상화된 클래스 즉 자료구조가 있고,
이 자료구조 내부에는 실제 이 자료구조를 구현하기 위한 방법들이
복잡하게 동작되어있는데 이것들을 신경쓸필요없고 인터페이스를 알고
활용할 수 있으면 된다.

* 재사용성 - 추상화를할 때 재사용성을 같이 고려해야한다.
재사용성이 좋다하는 것은 특별한 상황에 효율이 좋은 것보다
효율을 낮추더라도 일반적인 상황에 사용할 수 있게 하는 것
다양하게 쓸 수 있게 하는 것.

### 자료구조 종류
* 선형구조 - af(x) = f(ax) f(x) is linear 선형의 기본 개념
선형 ---일자로 되어있는것 하나가 있으면 그 다음게 있고 일자로 쭉 되어있는 것 

* 비선형구조 - 막 꺽여있는 구조. 데이터가 있으면 두갈래가 되고
돌아오는 것도 있고 1자로 되어있지 않은 것 hard...

* 자료가 어떻게든 연결될 수 있으면 비선형 
부모 자식 관계같은 것도 비선형 자식들을 무한히 낳을 수 있고
못 낳을 수도 있고 하다.. 부모는 여럿이 될 수 없다.
* 트리구조에서 부모가 없는 것은 맨 위에있는것 하나 뿐이다.

## 자료구조의 필요성
* 기본적으로 프로그램을 구현하면 다양한 자료를 임시적으로 메모리에
올리거나 영구적으로 파일 시스템, 데이터베이스에 저장하여 사용한다.
자료는 어떻게 저장하는지에 따라 중대한 영향을 끼친다.
* 우리가 자료를 선택하는것은 효율적으로 빠르게 접근할지,
저장장치를 효율적으로 사용할지에 대한 트레이드 오프이다.

1. 효율적으로 빠르게 접근할 수 있는지가 결정된다
h2 db를 쓴다했을 때 id, score가 있어서 학생의 id와 점수가 있는데
한번받아오는데 20초가 걸린다하면 이 데이터베이스는 안쓰게 될것이다

2. 저장장치를 효율적으로 사용할지 

3. 자료구조를 잘 선택하면 알고리즘을 기꼐적으로 적용할 수 있다?
가장 효율적으로 계산할 수 있는 알고리즘 내부적으로 가지고 있다
그래프라는 자료구조를 표혆안했다면 다익스트라 알고리즘을 사용할 수없고
그래서 자료구조를 잘선택해야 알고리즘을 잘 사용할 수 있다.

4. 동료들과 협업하는데 큰 도움이 된다(잘못된 창의성을 발휘하지 않게 도와준다.)
무슨 자료구조 알고리즘을 써서해결했다고 말하면 되는데 그런것을
모르고 사용햇따하면 협업을 할수없다?

* 극한의 유연성을 가지고 있는 언어를 가지고 왜 일부만 사용해야 하냐 라고 생각하는 사람이 있는데
* 소설을 쓰고싶으면 한글이있고 문법에 맞게 써야하는데 소설을 꿹 뷁 뷹 즵 같이 쓰는 것과 비슷하다
* 컨벤션과 롬복이 있을 때 훨씬 효율적으로 쉽게 잘 할 수 있다. 제대로 한글을 쓰자라는게 자료구조를 쓰자라는 것이다.
* 그래서 자료구조를 배워야 한다.

### java와 자료구조
* 자바는 자료구조가 잘 구현되어있다 jcf에 구현되어있다.
List, arrayList, linkedList 제네릭인터페이스를 사용하면 안전하게 사용할 수 있다.
제네릭을 사용하는걸 기본으로 하면 된다.
Map - hashmap, treemap
set - hashset, treeset


## 알고리즘
* 정의 - 문제를 해겨하기 위한 여러 동작들의 모임 여러 동작이라는것이 명명백백해야한다?

### 조건
* 입력 - 외부에서 제공되는 자료가 존재한다. 소팅되어있는 리스트같은?

* 출력  - 적어도 2가지 이상의 다른 결과를 출력해야 한다?
입력달라지면 결과도 달라질 수 있어야 한다.
입력이 하나면 출력도 하나가 되어야 한다?
출력하나에서 입력 여러개가 연결될 수 있다.
입력하나에서 출력이 여러개 나갈 순 없다.
모든 입력에 대해 동일한 출력을 내서는 안된다.
최소한 2가지이상의 출력의 종류는 있어줘야한다
대표적 2가지 출력 true, false


* 명확성 - 수행과정은 명확한 명령어로 구성되어 있어야 한다.
명확한 명령어는 여러 동작들이 아주 명확해야한다 다른말로
코드로 작성할 수 있어야 한다.
강단에서 뒤에앉은 사람들을 앞줄에 앉힐 때
while not_done {-> 더 옮길 수 있고 사원일 경우
1. 맨앞에 맨왼쪽에 앉은 사람을 선택
2. 더 앞으로 갈 수 있는지 확인
3. 가능하면 앞으로 한칸 옮긴다.
4. 더 앞으로 못가면 제외한다.
}
이런게 명령들이 명확해야 한다는 것이다.

* 유한성 - 유한한시간안에 종료되어야 한다.
무한루프가 있으면 안된다. 무한하게 돌고 있으면 알고리즘이 아니다.
전체적으로 무한루프로 돌고 있는 프로그램이다 알고리즘은
입력이 들어오면 출력을 내주는 것이 알고리즘

* 효과성 - 모든 과정은 사람이 종이와 연필로 유한한 시간안에 
수행할 정도로 단순/명백해야 한다.

### 알고리즘의 필요성
* 서비수의 규모가 엄청커지고 아이템이 수백만개가되고 이용자도 수십만이 되고 하기 때문에
규모가 점점커지기 때문에 알고리즘이 필요함.

* 컴퓨터 연산 속도와 비용
* 최근에는 클라우드로 서비스를 제공한다.
* 물리적으로 서버를 구매 관리 유지 하지 않아도 되고
서버액세스가 급격하게 증가하면 유연하게 인스턴스 수를 늘리도록 대처 가능
* 보안과 안전성 등 소규모 기업이 직접해결하기 어려운 문제를 쉽게 해결할 수 있다.
그러다보니 서버를 임대하기 때문에 서버의 스펙과 시간에 비례해서 돈을 내게 되어있다. 
* 더 좋은 알고리즘으로 연산속도를 개선할 경우, 더낮은 서버 스펙으로도 동일한 서비스를 제공할 수 있다.
* 동일한 batch 작업에 더 좋은 알고리즘을 사용할 경우 동일한 서버 스펙으로 더 짧은 서버를 임대해도 동일한 결과를 얻어낼 수 있따.
* 인프라를 사용하는 것과 직결되기 때문에 알고리즘을 잘 적용하는 것으로 수억 수천만원을 아낄 수 있다.
* 컴퓨터의 연산 속도가 비용으로 측정되는 것 때문이다.

### java와 알고리즘
* java는 high-level 랭귀지로 알고리즘을 효율적으로 구현하기 위한 언어는 아니다.
c, c++이 훨씬 더 효율적인 언어이다.
* 하지만 typed언어이면서 설계를 중시하기 때문에 구현 속도는 느린편이여서 구동속도는 중- 중상 수준이다.
oop, fp 모두 지원해서 잘짜여진 자료구조. 알고리즘을 구현할 수 있고  미션 크리티컬한 로직만 구현할 수 있다,
알고리즘의 최고로 좋은 언어는 아니지만 나쁘진 않다.

## 코딩 테스트
### 목적
* 빠르고 효율적으로개발자 실력을 가늠하기 위해 사용
개발자의 코딩 습관도 간접적으로 확인할 수 있다.
* 공통적으로 개발자가 필요로 하는 역량을 준비할 수 있다.
* 각 회사에서원하는 시험을 만들어서 하는 것이기 때문에
코딩테스트에 녹여서 내기 때문에 코딩테스트를 여러번 보는것이
중요한게 회사에서 추구하는 것이 달라서 공통적으로 개발자가
필요로 하는 역량의 창구이고 맞춰서 준비할 수 있다.


### 출제 유형
#### 프로그래밍 언어의 기본 라이브러리를 이용한 효율적인 구현
반복문, 조건문
array 검색 정렬
* 예외처리(빈 리스트라던지 처리하기 어려운 예외적인 입력)를 위한 모든 testcase해결 
반드시 나온다. 이정도는 잘 할 수 있어야 한다..

#### 자료구조를 이용한 기본 구현
map, set, heap 등 특수한 기능을 갖춘 자료구조 활용
이걸 사용하면 바로 풀리는 문제들이 있다.

#### 잘 알려진 알고리즘 활용
sort, dynamic programming, dfs, bfs, greedy, dijkstra...
다이나믹 프로그래밍은 굉장히 중요함 항상 나옴
실제 실무를 하면서도 많이 나온다...
 * 다 잘 배워서 써야 한다. 그 자리에서 생각해서 푸는건 불가능하다. 시간을 아껴서 해야 하기 때문에 공부해두자

#### 규격 외의 문제
위 유형에 속하지 않는, 고난이도의 문제 는 기업 코딩테스트에 출제 되지 않는다...

## 알고리즘의 복잡도
* 공간 복잡도 vs 시간복잡도(계산복잡도) -> 일반적으로 트레이드오프관계
시간복잡도를 적게가져갈려면 공간복잡도 메모리를 많이써야 한다

* 알고리즘의 복잡도가 높을 수록 구동하는데 더 많은 코스트가 소비된다.
* 코스트는 클라우드를 사용하면서 스펙을 올린다거나 시간을 늘어난다거나
더 많은 비용을 내게 되는데 이런 비용으로서의 코스트 금전적인 코스트와 엔지니어링의 코스트가 있는데
여기선 엔지니어링의 코스트이다.

* 공간복잡도는 알고리즘이 동작하기 위한 공간 메모리의 크기
많은 경우 연산의중간 결과를 저장하기 위해 메모리를 소비
  중간 결과를 저장하여 중복 연산을 줄일 수 있다.

* 오해 하지 말아야 할점..
  * 어떤 알고리즘이 있으면 공간복잡도가 증가시키면 무조건
시간복잡도가 감소하지 않는다.. 더 안좋게 될 수도 있따.
알고리즘의 성능 차이가 존재한다 좋은 알고리즘과 나쁜 알고리즘이
있다는 것

* 동일한 메모리를 사용하면서 시간을 짧게 사용할 수 있는
좋은 알고리즘이 있다는 것

* 복잡도사이의 트레이드오프가 있다는 것은 최적의 알고리즘을
사용하는 것이 아닐 때를 말하는 것이다.
무조건 트레이드오프 관계는 아니라는 것이다.

* 시간 복잡도는 알고리즘이 동작하는데 걸리는 시간 또는 연산의 횟수
연산의 횟수로 이야기하는게 더 좋다
 * 똑같은 알고리즘이여도 서로 다른 머신에서 동작을 할 때
아이폰이랑 슈퍼컴퓨터에서 동작할때 당연히 슈퍼컴퓨터가
빠르니깐 시간으로 따지는 것보다 연산의 횟수가 더 좋다.


### 복잡도의 계산 방법
#### 시간복잡도 
* 측정 방법 - 알고리즘을 구동하면서 기본연산의 연산횟수 카운팅
기본연산 -> 대입, 연산 가장 작은 연산을 의미
논란의 여지가 굉장히 많음 기본연산의 기준을 어디까지 보느냐의
차이가 있다.
sum = 0; 이것도 어떻게보면 기본연산이다.

* 분석을 하는것이 더 적합한 방법
   * 코드를 보고 분석하는 것 반복문과 조건문을 고려하여
   분기별로 실행 횟수를 분석하여 알아낼 수 있다.
* array가 n개가 있다하면 for문은 n번 동작한다.
i에 대입되는연산이 n번동작 sum에 덧셈 대입 연산 까지 합치면
3n이 된다.
* 리니어하게 쭉 증가하는 시간복잡도가 증가하는 알고리즘이다.
자료가 10만개면 30만이라는 시간복잡도를 가지게 된다는 것

### 복잡도의 종류
* 최악의 경우
* 최선의 경우
* 평균적인 경우

* 리스트에 값을 넣는다 했을 대 맨마지막에 넣으면 복잡도가 1이다(베스트)
* 맨앞에 넣으려고 하면 원래있던 값들을 뒤로 넘거야하니 n개의 값을 
넘겨주고 1개의 값을 넣어줘야하니 복잡도는 n+1이다.(워스트)
* 평균적인 것은 모든 경우의 수를 계산해서 구한다? (n+1)(n+2)/2(n+1)로 해서 평균을 구하는 것이다.
매변 평균을 따지는게 쉬운게 아니다.


## asymptotic notations
* 점진적(리미트?) 표기 방법 더 이상 그래프가 역전이 일어나지 않은 부분을 말함
그래서 n2 > n보다 크다라고 말할 수 있는 것이다.
* 그래프가 어떻게 꼬여있건 마지막에 어떻게 되는지만 알면된다.

* 알고리즘의 자료의 개수가 충분히 많다고 가정한다.
* 입력자료의 개수가 작은 경우, 비교하는 의미가없기 때문에

* 성능 평가에 공평한 비교를 위해 성능 분석 기준으로 사용
동작시스템(시간에 영향을 줄 수 있는데 연산횟수로가능하기 때문에)
  데이터 크기 등을 배제하고 성능 비교하기 위해 필요하다

### big-o 노테이션
* f(n) = n n2 3n+2 등이 잇을 때 o(g(n))으로 바꾸는게 목표이다?

* 정의를 가지고 이야기하기보다 개념적으로 이야기해보자
  * 점진적방법은 더이상 역전이 일어나지 않는 큰 수에 대해서만
  따진다 그게 n0 이다 이 이후만 보면 된다.
  시간복잡도  f(n)이라는 함수가 있을 때 gn이 0보다 큰 c를곱해서
  f(n) 위로 올릴 수 있다면 사용할 수 있다.
  * f(n) = n2+3, cg(n) = 2*n2일 때
  특정지점을 기준으로 2*n2이 더 커지게 된다.
  그래서 n2+3은 gn을 n2으로 써서 o(n2)으로 사용할 수 있다.
 

* o(n2) -> n2보다 낮은 o(n)이 포함된 n2+o(n)

* o(n2) - > n2이 최고차수인 것들이 다 포함된다.
* o(logn) < o(n)이기 때문에  o(logn) 이것도 포함
n2보다 느리기만 하면 다 들어간다. 3n, 4등도 포함 가능.

* o(n2) 이라고 할 때 f(n)이 n2에서 아무리 값이 높아도
on2안에들어감 c*g(n)이니깐 c에 0이상 아무값을 넣을 수 있으니깐

### 복잡도 순위
* 상수가 가장빠르고 팩토리얼(소수구하기?)이 가장 느림

### big-omega 노테이션 - 느린거?
빅오와반대로 f(n) <  cg(n)
빅오는 이것보다 빠른게 들어가고 복잡도의 순위에서 상수가 가장빠른거니간
자신보다 최고차수가 낮은 것들이 포함되니깐 빠른게 들어가는 것

빅오메가는 이것보다 느린게 들어간다.
높은 차수가 들어간 다는 것

### big-theta 노테이션 - 정확히 일치 최고 차수가 같은게 들어가야함?
빅 오와 빅오메가에 둘다 들어가야 빅 세타에도 들어간다
n2 이라고 하면 n2+3n+1 n2+3+2n 
n2이 최고차수인 것들만 들어갈 수 있다. 3n, 4n3이 들어갈 수 없다

그래프 상에 위에있는게 더 느린것 시간복잡도가 높은거니깐 속도가
느린것 하지만 그래프상에서 증가하는것이 빠른 것이다.

그래프에서 아래있으면 알고리즘상 빠르다.

