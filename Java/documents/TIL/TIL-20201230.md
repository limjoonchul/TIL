# 오늘의 일정
* 오전에 어제 수업했던 내용 복습하기
* 1시부터 운영체제 / 네트워크 수업 듣기
* 7시부터 스프링 심화 수업 듣기 
# 오늘의 공부한 내용
* 어제 수업했던 스프링 심화 수업 정리했다.
* 1시부터 5시까지 운영체제 / 네트워크 수업을 들었다.
* 7시부터 스프링 심화 수업을 들었다.
# 오늘 공부하면서 배운 점 및 생각
## 어제 수업내용 복습
* 검증할 때 사용하는 @NotEmpty, @NotNull, @NotBlank 등이 있다.
  * @NotEmpty는 스트링에서 주로 사용하는데 스트링의 기본값이 null이지만, `""` 으로 디폴트 값이 되어 있을 수도 있는데
   @NotEmpty는 스트링이 null인지와 `""`이 인지를 체크한다.
  * @NotNull은 객체 자체가 없는 것인지 체크한다  Object == null 인지 확인
  * @NotBlank는 null인지, `""`(공백 문자) 인지, `" "`(화이트 스페이스) 인지를 체크하는데
  어떻게 보면 이게 더 많은 조건을 체크해주기 때문에 더 사용을 해야 하지 않을까 생각하지만
  요새 추세로 RESTapi를 사용하는데 이것에서 값을 받을 때 trim으로 공백을 제거하기 때문에 `" "` 로 넘어와도  `""`과 같아져서
  더 명확하게 @NotEmpty를 사용한다. @NotEmpty는 null과 `""`를 체크하니깐

* 영어권개발자들은 모국어가 영어이기 때문에 인코딩에 대해서 크게 신경쓸 필요가 없다
그래서 미쳐 인코딩을 신경쓰지 못하고 개발을 할 수가 있다.
MockMvc를 이용하여서 테스트를 진행했는데 인코딩 문제가 발생했었다.
* 그래서 addFilters를 이용해서 CharacterEncodingFilter를 넣어 인코딩문제를 해결했다.
```groovy
 @BeforeEach
    public void before(WebApplicationContext was) {
        mockMvc = MockMvcBuilders.webAppContextSetup(was)
                .addFilters(new CharacterEncodingFilter("UTF-8",true))
                .alwaysDo(print())
                .build();
 }
```
* 스프링 빈에 오토컨피규레이션으로 등록되어 있는 빈이 있는데 이 빈을 새롭게 등록하려고 하면
에러가 난다.
* MockMvc Test는 mock을 이용해서 스프링부트에서 http로 byte단위로 통신을 하는 가짜 요청과 응답을 만들어서
마치 서버가 띄워져 있는 것처럼 테스트하는 방법이다.

### 테스트의 종류
* 브라우저에서 웹 테스트 - 브라우저에서 직접 하나하나 체크리스트를 만들어서 동작시켜보면서 테스트하는 것인데,
체크리스트에 맞춰서 필요한 테스트를 모두 진행할 수 있으면 제일 정확한 테스트 방법이다.
하지만, 사람이 직접 테스트를 일일히 하는 것이다 보니 실수로 체크리스트의 항목을 빼놓고 테스트를 할 수 있어서
어떻게보면 정확도가 떨어질 수도 있다.

* .http 파일로 테스트

* MockMVC 테스트 - 간단하게 테스트를 할 수 있는데 가짜의 환경을 만들어서 하는 테스트이기 때문에 정확도가 떨어질 수 있다.

* 서비스에서 Mock 테스트
 
*  브라우저 테스트가 100%의 정확도를 가진다면 목테스트는 99% 가된다.
100% x 1 vs 99% x 100 일때, 실제로 많은 테스트를 하는게 오류날
확률이 적어지는 것이다.

* 사람이 직접 테스트하는 브라우저 테스트를 놓친다면 0%가 되버릴 수 있으니
기계가 하는 목 테스트를 하는게 좋다.
### 테스트의 정확도
* 브라우저 테스트 > 호출테스트(.http) > MockMVC테스트
* RESTapi 정확도 : 브라우저 테스트 = 호출테스트 > MockMVC 테스트
* 편리성 : MockMVX테스트(월등히 좋음) > 호출 테스트 > 브라우저 테스트

* 모든 테스트를 다 진행해야 하는 건 아니다 결국 중요한 점은 내가 만든 로직이 잘 동작 하는지, 다른 로직에 영향을 주지 않는지
이런걸 확인하는 것에 목적이 있기 때문에 어떤걸 진행해도 상관이 없지만 다만 좀 더 편리하고, 정확하게 하는 목적에 따라
테스트 방식이 달라지는 것 같다.
* 다만 css/ html처럼 레이아웃의 경우 브라우저에서 직접 확인 해서 변경된 내용, 깨지지 않느지 등을 확인 해야 하기 때문에
브라우저에서 해야 하는 것이다.

### 오류(장애)  어제 수업중 가장 중요한 부분!
* 프로그램을 개발하다 보면 오류는 나올 수 밖에 없다.
오류가 안나는 프로그램을 만들기 보다 오류를 빠르게 고치는데 의의를 둬야 한다.
오류를 빠르게 잡아내는 것이 곧 비용과 연관되니깐

*  컴파일 에러에서 잡아내는게 가장 좋다. -> 테스트 에러 ->  스프링 부트 Run 에러(런타임 초기)
-> 브라우저, 실환경 런타임 에러(실제 장에) -> 가장 안좋은 케이스는 런타임 에러인데 논리적인 에러이다.

> 논리적인 에러는 100원을 이체했는데 1000원이 이체 되는 경우 같은 것 에러 찾기가 매우 힘들다
> 그래서 최대한 앞 단계에서 에러를 잡아내도록 하는게 좋은 것이다.
> 이렇게 앞쪽으로 에러를 잡을 수 있게 당길려고 나온 것들이 방법론 같은 것들이다.
> 스프링 부트에러까지는 서버가 뜰 때까지는 반응을 빠르게 해서 에러를 처리할 수 있어서 괜찮고,
> 브라우저, 실환경 런타임 에러도 에러가 로그에 쌓여서 확인을 할 수 있지만,
> 논리적인 에러는 보통 확인이 거의 안되고 범위도 파악하기 어렵다.
> 그래서 누군가 내 코드를 건드릴 때 앞 단계에서 에러가 날 수 있게 final(재할당 불가)로 지정한다든지 컴파일 에러가 나도록 설정한다.

* 테스트를 잘 만들었다라고 하는것은, 프로덕션 코드를 고쳤을 때 반드시 테스트가 에러가 나야 한다
SRP처럼 단일 책임 으로 한 곳을 고치면 한곳에서 에러가 나야 하지만 이론적인 애기고 최소한의 범위에서 에러가 나야한다.
이런 원칙에 맞춰서 개발하도록 노력하다보면 좋은 개발자가 될 것이다!

### DTO - Data Transfer Object
* 계층 간에 전달이라는 것에 중점을 두고 있다.
* 좋은 코드를 짜는 책들에서 파라미터 개수를 최소화하라고 나오는데,
3개 이상이면 오브젝트로 묶을 수 있는지 고민해보라고 나온다.
* 파라미터가 많아질 때 사용하는게 DTO이다, 그렇다고 여러개의 파라미터가 나왔다고해서
꼭 하나의 DTO로 묶는게 아니라 파라미터에 따라서 공통된 DTO로 나누어 묶을 수도 있다.

#### DTO를 사용하는 이유
* 결국 JSON을 만들기 위한 것이다. 프레젠테이션 레이어에 있는 뷰에서
컨트롤러에 데이터를 전달해 주기 위한 것으로 DTO를 사용한다.
#### VO - Value Object
* vo라는 것도 있는데 이건 값에 더 중점을 갖고 있는 것이다.
핵심은 value가 변조되지 않는 것이고 getter만 제공한다.


  
### JSON - Javascript Object Notation
* 제이슨은 데이터를 주고받는데 사용되는 문서의 양식이다.
hwp, doc 과 같은 문서라고 생각 하면 된다.
* 형식이 심플해서 최근 많이 사용한다.
* JSON으로 넘겨온 값은 타입을 따로 가지고 있지 않아서 String으로 파싱이 해서
Get Parameter Binder가 컨트롤러에 들어오는 시점에 해당 설정된 타입으로 파싱해준다.
  * 모든 파라미터를 String으로 받게 되면 잠재적인 오류가 있을 수 있으므로 컴파일 에러에서 잡기 힘들다
  그러니 타입들도 적절하게 맞춰서 사용하는 것이 좋다.
* .yml, .yaml로 표현하기도 하는데 이것이 변형된 json파일이다.  
#### JSON 이전 데이터 교환 방식
* File(텍스트) - apple@@@banana@@@peach@google.com
이렇게 파일을 작성했을 때 이름들을 나열하다 이메일을 작성하는 것처럼
@@@로 구분하다 이메일에서 @도 나오니 파싱하는데 문제가 생긴다.

* XML - 계층하된 도식 데이터를 나타내기 좋았다, 하지만 복잡하고 작성되는 데이터 이외에
`<XML></XML>` 형식처럼 추가되는 문자수가 더 많이 차지하게 되는 문제가 있다.

#### JSON 타입
* 객체, 문자열, 숫자, Key/ value(map), 배열(List), boolean, null 타입을 지원한다.
* JSON을 시작할 때 {...} 로 시작하는데 이것은 JSON도 기본적으로 하나의 객체라는 의미이다.

* 키 벨류 쌍에서 꼭 키를 스트링으로 사용해야 하는거 아닌데 언어마다 키를 숫자로 지원하고 안하고의 차이가 있어서
스트링을 사용하는게 좋다.
* 주석을 지원하지 않는다.
* 아래처럼 계층하된 형태로도 만들 수 있다.
```json
{
  "name" : "martin",
  "age" :  10,
  "hobby" : { 
      "name" : "reading",
       "period" : 10
  }
}
```
### 프론트엔드와 백엔드 협업
* 백엔드와 프론트엔드를 연결하는 과정이 데이터 통신(JSON)으로 이루어진다.
* 클라이언트 사이드 렌더링, 서버 사이드 렌더링(JSP, Servlet)이 있는데
이 두가지로 나눠진게 서버 사이드로 했을 때 서버 개발자가 모든걸 다 하기 어려웠다.
아이폰이 처음 나올 무렵부터 화면 쪽이 많이 발전해서 스크립트를 랜더링 해주는 엔진들도 좋아지고, 또 복잡해져서
영역을 나눠서 각자의 전문성을 살리는 방식으로 변화해 갔다.

* MSA - Micro Service Architecture
  * 아키텍쳐를 단일 책임으로 만들어서 각각의 아키텍쳐가 자신의 역할만 하도록 하는 것

* 서버 사이드 렌더링은 페이지 전체를 한번에 로딩하기 때문에 느리다.
그리고 동기 방식이기 때문에 모든 화면이 다 만들어지기 전까지 렌더링이 안된다.
크게 한번 통신 한다.
* 클라이언트 사이드 렌더링은 조각 조각 만들어서 작게 여러번 통신한다.
구간별로 렌더링하니 빠르고, 한 부분이 에러가나도 정상적인 구간은 렌더링이 된다.
화면은 한번 캐싱하게 되서 가지고 있으면 변경된 데이터만 바꾸게해서 캐싱이 빨리진다.

* 백엔드는 데이터만 담당하고 프론트는 뷰만 담당한다.
백엔드가 데이터라는(api 제공) 결과물을 json으로 보내면 프론트에서 ajax로 api를 호출하고 json결과를 가져간다.

* 협업에 필요한게 url이 필요하고 어떤 파라미터를 받을지
어떤 url로 받을지 json을 어떤 데이터가 포함되어 있어야하는지
협의해서 만들게 될것이다? 데이터에대한 규격을 맞춰주면 된다.

### ObjectMapper
* 전달 받는 데이터가 스트링인 경우 파싱을 하면되는데 객체를 매핑하는 것이다.
외부의 객체를 자바의 객체로 매핑해주는 것이 오브젝트 매퍼의 역할이다.

* 스프링의 오브젝트에도 시리얼라이저블 인터페이스를 implement해주면
이 객체도 직렬화를 해준다 직렬화 통신에 사용할 수 있도록 변경해주고 사용한 바이트들을 다시 객체로 복원시켜준다?

* 오브젝트 매퍼를 하는 이유는 자바 객체는 자바만 파싱이 가능해서 스프링 버전이 달라지게 되면
직렬화 비직렬화(복호화) 하는게 안될 수 있다 그럼 데이터 전달 방식에 문제가 되니깐
오브젝트 매퍼를 사용하여서 외부의 객체를 자바의 객체로 매핑해주는 것이다.

* Json을 매핑해주는 오브젝트 매퍼 구현체로 Jackson, gson을 많이 쓰는데 스프링에는 Jaskson이 스타터에 내장되어 있다.
 