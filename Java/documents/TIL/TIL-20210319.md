# 오늘의 할 일
* Startup Coding Festival 모의테스트 풀어보기
* 알고리즘 강의 2개 이상 듣기
* 알고리즘 2문제 이상 풀기

# 오늘 한 일
* Startup Coding Festival 모의테스트를 풀어봤는데 2문제였다. 
1번 문제는 60점... 2번 문제는 50점으로 완벽하게 문제를 해결하지 못했다. 되게 간단한 문제라고 생각이 들었는데
안 풀려서 너무 짜증이나고 오랜 시간을 그 문제들로만 잡고 있을 수 없으니 일단은 종료하고 나중에 더 공부해서
다시 풀어봐야겠다.

* 시간복잡도에 대해 알고리즘 강의를 들었다. 학원을 다니면서 한번 짧게 들었던 적이 있어서 그런지
비교적 이해하는데 큰 무리는 없었다.

* 알고리즘은 쉬운 문제 하나 풀고, 다른 문제풀다가 다 풀지 못하고 끝냈다.. 많이 많이 풀어봐야 하는데
간단한 문제도 오래 걸리고, 다른 강의들도 보다보면 시간이 부족하다.

# 배운 내용 정리
## 알고리즘 복잡도 계산이 필요한 이유

하나의 문제를 푸는 알고리즘은 다양할 수 있다.

- 정수의 절대값 구하기
    - 방법1: 정수값을 제곱한 값에 다시 루트를 씌우기
    - 방법2: 정수가 음수인지 확인해서, 음수일 때만 , -1곱하기
- 다양한 알고리즘 중 어느 알고리즘이 더 좋은지 분석하기 위해, 복잡도를 정의하고 계산함.

알고리즘 시간 복잡도의 주요 오소

- 반복문을 가지고 시간복잡도를 계산한다.
- if문을 몇개 쓰느냐 변수를 몇개 선언하느냐 이런건 크게 영향을 주지 않는다.

### 알고리즘 성능 표기법

- 빅오 표기법 : O(N)
    - 가장 많이  일반적으로 사용함
    - 아무리 최악의 상황이라도 이정도의 성능은 보장한다는 의미이다,
    - 알고리즘 최악의 실행 시간을 표기한다.
- 오메가 표기법
    - 알고리즘 최상의 실행 시간을 표기
- 세타 표기법
    - 알고리즘 평균 실행 시간을 표기
- 시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중 최악의 시간인 빅오 표기법을 중심으로 익히면 된다.

### 대문자 O 표기법

- 빅 오 표기법
- O(입력 n)
    - 입력 n에 따라 결정되는 시간 복잡도 함수
    - 입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있다.
        - O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(2n) < O(n!)
            - 참고 : log n의 베이스는 2이다 (log2n)
            - 작을 수록 성능이 좋음
    - n에따라서 실행되는 것이 없으면 무조건 상수회 정도 실행한다 - O(1)
    - n에따라 n번 , n + 10, 3n + 10은 O(n)
    - n에 따라 n2번, n2 + 10, 3n2 + 10 은 O(n2)