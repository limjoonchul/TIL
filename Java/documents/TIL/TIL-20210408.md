# 오늘의 할 일
* 알고리즘 강의 3개 들으면서 내용 정리 및 복습
* 알고리즘 문제 3문제 풀고 풀이 정리해서 github에 올리기
* 인프런 스프링 강의 3개 듣고 내용 정리

# 오늘 공부한 내용
* 동적 계획법과 분할 정복, 퀵 정렬, 병합 정렬에 대해서 알고리즘 강의를 들었다. 파이썬으로 된 강의라
자바로 작성할 때 다른 부분들이 있어서 그런 부분들을 찾아보고, 구현 하느라 굉장히 오래 걸렸다.
    > 퀵 정렬까지만해도 그래도 구현된 코드들을 보면 이해가 되서 들었는데 병합 정렬은 정말 어려웠다...
    혼자서 구현하는 연습을 정말 많이 해봐야 될 것 같다.

* 알고리즘 [수 정렬하기3](https://www.acmicpc.net/problem/10989) 문제를 풀었는데, 카운팅 정렬이라는 알고리즘에 대해서 몰라서
블로그와 유튜브에서 찾아서 참고하면서 문제를 풀었다. 정말 정말 알아야할게 너무 많아...


## 공부한 내용 정리

### 동적 계획 법과 분할 정복

- 두 개가 다른 기법인데 유사한 점이 많음

### 1. 정의

- 동적계획법(DP, Dynamic Programming)
    - 입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 답을 활용해서, 보다 큰 크기의 부분 문제를 해결하면서 최종적으로 전체 문제를 해결하는 알고리즘
    - 상향식 접근법으로, 가장 최하위 해답을 구한 후, 이를 저장하고, 해당 결과값을 이용해서 상위 문제를 풀어가는 방식이다.
        - 하위 문제를 저장하는 것은 예를 들어 중간 문제 2개가 존재한다고 할 때, 이 두 문제 모두 작은 문제 하나를 공통적으로 필요하다고 하면 중간 문제를 풀려고할 때 공통된 작은 문제가 각 각 계산되어지니깐 시간적으로 낭비가 된다 그래서 한번 문제를 풀면 저장해 놓는 것이다(메모리제이션 기법!)
    - Memorization 기법을 사용함
        - 프로그램 실행 시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기술
    - 문제를 잘게 쪼갤 때, 부분 문제는 중복되어, 재활용된다.
        - 예 : 피보나치 수열
- 분할 정복(Divide and Conquer)
    - 문제를 나눌 수 없을 때까지 나누어서 각각 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘
    - 하향식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식
        - 일반적으로 재귀 함수로 구현
    - 문제를 잘개 쪼갤 때 부분 문제는 서로 중복되지 않는다.
        - 예 : 병합 정렬,  퀵 정렬 등

### 2 .공통점과 차이점

- 공통점
    - 문제를 잘개 쪼개서, 가장 작은 단위로 분할
- 차이점
    - 동적 계획법
        - 부분 문제는 중복되어, 상위 문제 해결 시 재활용 된다.
        - Memorization 기법 사용.
    - 분할 정복
        - 부분 문제는 서로 중복되지 않는다.
        - Memorization 기법 사용 안함.
### 퀵 정렬 과 병합 정렬
### 1. 퀵 정렬(quick sort)

- `정렬 알고리즘의 꽃`
- 기준점(pivot 이라과 부름)을 정해서, 기준점보다 작은 데이터는 왼쪽, 큰 데이터는 오른쪽으로 모으는 함수를 작성함
- 각 왼쪽, 오른쪽은 재귀용법을 사용해서 다시 동일 함수를 호출하여 위 작업을 반복함.
- 함수는 왼쪽 + 기준점  + 오른쪽을 리턴한다.
- 보통의 경우 시간복잡도가 빠르다.

#### 퀵 정렬 순서

1. 피봇 선택
2. 분류하기 - 피봇보다 작은 데이터는 왼쪽 큰 데이터는 오른쪽으로 분류한다.
3. 그 다음 이제 왼쪽 오른쪽으로 나누어진 데이터 그룹별로 1,2번을 데이터의 수가 1이 될때까지 반복한다.

#### 알고리즘 분석
- 병합 정렬과 유사, 시간복잡도는 O(n  log n)
    - 단, 최악의 경우
        - 맨 처음 pivot이 가장 크거나, 가장 작으면 모든 데이터를 비교하는 상황이 나온다.
        - 이때 O(n^2) 시간복잡도를 갖는다.
        - 보통 빅오표기법은 최악의 시간복잡도를 나타내지만, 최악의 경우가 너무 극단적인 시간복잡도를 갖게 되면 보통 평균적인 시간복잡도를 해당 알고리즘의 시간복잡도로 표기하기도 한다.
- 각 하위의 단계가 O(logn) 만큼의 시간복잡도를 가지며 생성이 되고, 각 단계별 n만큼 정렬하는데 피봇과 비교하는데 시간이 걸려서 O(n log N) 의 시간복잡도를 갖는다.

### 2. 병합 정렬(merge sort)
- 재귀 용법을 활용한 정렬 알고리즘

    1. 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.

    2. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.

    3. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.
    