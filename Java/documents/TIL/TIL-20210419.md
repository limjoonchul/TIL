# 오늘 해야 할 일
* 인프런 스프링 강의 3개 들으면서 내용 정리 및 이전 내용 복습
* 알고리즘 강의 3개 듣고 내용 정리 및 이전 내용 복습
* 알고리즘 3문제 이상 풀기
* 프리 다이빙 프로젝트 UseCase 그려보기

# 오늘 공부한 내용 및 느낀 점
* 인프런 스프링 강의 여러개 조회된 빈들이 모두 필요로 할 때 어떻게 처리를 하는지,
자동 주입과 수동 주입을 어느 상황에 써야 하는 건지,  빈 생명주기 콜백에 대해서 들었다.

* 알고리즘 강의 최단 경로에 대해서 강의를 들었다.

* 알고리즘 문제 
    * [세로읽기](https://www.acmicpc.net/problem/10798)
    * [최대공약수와최소공배수](https://www.acmicpc.net/problem/2609)
        * 유클리드호제법 방법을 참고해서 문제를 풀었다.
    * [소트인사이드](https://www.acmicpc.net/problem/1427)
        * 배열을 정렬하는 것은 쉽다고 하고, 정수만 주어지고 정렬을 하라고해서 배열을 사용하면 안되나 생각이 들다가
        ArrayList를 사용해서 해봤는데 통과되었다.
    * [단어정렬](https://www.acmicpc.net/problem/1181)
        * 처음에 통과를 했는데 시간이 너무 길게 나와서 시간을 줄이는 로직이 없을까 보다가
        찾아보다가 중복을 제거하는 부분에서 다른 사람들과 차이가 있었다. 그래서 다른 사람들이 구현한 방법을
        보고 적용해봤더니 거의 6분의 1 가량 시간이 줄었다. 혼자서 중복제거 부분을 생각해서 구현하진 못했지만
        그래도 새로운 로직에 대해서 배웠다!
* 혼자서 프리 다이빙 프로젝트 UseCase 다이어그램을 그려보는 연습을 해봤다.

## 스프링 강의 내용 정리
* 데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 
애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.

* 간단하게 외부 네트워크에 미리 연결하는 객체를 하나 생성한다고 가정해보자. 실제로 네트워크에 연결하는 것은 아니고, 단순히 문자만 출력하도록 했다. 이 NetworkClient 는 애플리케이션 시작 시점에 connect() 를 호출해서 연결을 맺어두어야 하고, 애플리케이션이 종료되면 disConnect() 를 호출해서 연결을 끊어야 한다.

```java
package hello.core.lifecycle;
public class NetworkClient {
 private String url; public NetworkClient() {
 System.out.println("생성자 호출, url = " + url);
 connect();
 call("초기화 연결 메시지");
 }
 public void setUrl(String url) {
 this.url = url;
 }
 //서비스 시작시 호출
 public void connect() {
 System.out.println("connect: " + url);
 }
 public void call(String message) {
 System.out.println("call: " + url + " message = " + message);
 }
 //서비스 종료시 호출
 public void disconnect() {
 System.out.println("close: " + url);
 }
}
```

```java
public class BeanLifeCycleTest {
 @Test
 public void lifeCycleTest() {
 ConfigurableApplicationContext ac = new
AnnotationConfigApplicationContext(LifeCycleConfig.class);
 NetworkClient client = ac.getBean(NetworkClient.class);
 ac.close(); //스프링 컨테이너를 종료, ConfigurableApplicationContext 필요
 }
 @Configuration
 static class LifeCycleConfig {
 @Bean
 public NetworkClient networkClient() {
 NetworkClient networkClient = new NetworkClient();
 networkClient.setUrl("http://hello-spring.dev");
 return networkClient;
 }
 }
}
```

- 실행 결과
    - 생성자 호출, url = null
    - connect: null
    - call: null message = 초기화 연결 메시지
- 객체를 생성하는 단계에는 url이 없고, 객체를 생성한 다음에 외부에서 수정자 주입을 통해서 setUrl() 이 호출되어야 url이 존재하게 된다.

### 스프링 빈의 라이프 사이클

- 객체 생성 의존관계 주입
- 스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완
료된다. 따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다. 그런데 개발자가 의
존관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까?
    - 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다. 따라서 안전하게 종료 작업을 진행할 수 있다.
- 스프링 컨테이너 생성  → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 → 사용 → 소멸전 콜백 → 스프링
종료
    - 초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
    - 소멸전 콜백: 빈이 소멸되기 직전에 호출

### 참고 - 객체의 생성과 초기화를 분리하자.

> 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는등 무거운 동작을 수행한다.
따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다. 물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 다 처리하는게 더 나을 수 있다.

### 참고

> 싱글톤 빈들은 스프링 컨테이너가 종료될 때 싱글톤 빈들도 함께 종료되기 때문에 스프링 컨테이너가 종료되기 직전에 소멸전 콜백이 일어난다. 뒤에서 설명하겠지만 싱글톤 처럼 컨테이너의 시작과 종료까지 생존하는 빈도 있지만, 생명주기가 짧은 빈들도 있는데 이 빈들은 컨테이너와 무관하게 해당 빈이 종료되기 직전에 소멸전 콜백이 일어난다. 자세한 내용은 스코프에서 알아보겠다.

## 알고리즘 강의
## 1. 최단 경로 문제란?

- 최단 경로 문제란 두 노드를 잇는 가장 짧은 경로를 찾는 문제이다.
- 가중치 그래프에서 간선의 가중치 합이 최소가 되도록 하는 경로를 찾는 것이 목적이다.

## 최단 경로 문제 종류

### 1. 단일 출발 및 단일 도착 최단 경로 문제

- 그래프 내의 특정 노드 u에서 출발, 또 다른 특정 노드 v에 도착하는 가장 짧은 경로를 찾는 문제

### 2. 단일 출발 최단 경로 문제

- 그래프 내의 특정 노드  u와 그래프 내다른 모든 노드 각각의 가장 짧은 경로를 찾는 문제

    > 따지고 보면 굉장히 헷갈릴 수 있으므로 명확히 하자면, A, B, C , D라는 노드를 가진 그래프에서 특정 노드를 A라고 한다. A외 모든 노드인 B, C, D 각 노드의 A 간에 각각 가장 짧은 경로를 찾는 문제를 의미한다.

### 3. 전체 쌍 최단 경로 : 그래프 내의 모든 노드 쌍에 대한 최단 경로를 찾는 문제 (A-B, B-C ,C-D ,D-A)

## 2. 최단 경로 알고리즘 - 다익스트라 알고리즘

- 다익스트라 알고리즘은 위의 최단 경로 문제 종류 중 2번에 해당
    - 하나의 정점에서 다른 모든 정점간의 각각 가장 짧은 거리를 구하는 문제

### 다익스트라 알고리즘 로직

- 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며, 최단 거리를 갱신하는 기법
- 다익스트라 알고리즘은 너비우선탐색과 유사
    - 첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접 노드 간의 거리부터 먼저 계산하면서, 첫 정점부터 해당 노드간의 가장 짧은 거리를 해당 배열에 업데이트

        > 다익스트라 알고리즘은 다양한 변형 로직이 있지만, 가장 개선된 우선순위 큐를 사용하는 방식으로 설명

- 우선순위 큐를 활용한 다익스트라 알고리즘
    - 우선순위 큐는 MiniHeap 방식을 활용해서, 현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼내게 된다.
    1. 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장
        - 초기에는 첫 정점의 거리는 0, 나머지는 가장  큰 값을 저장함
        - 우선순위 큐에  (첫 정점, 거리 0)만 먼저 넣음
    2. 우선순위 큐에서 노드를 꺼냄
        - 처음에는 첫 정점만 저장되어 있으므로, 첫 정점이 꺼내진다.
        - 첫 정점에 인접한 노드를 각각에 대해, 첫 정점에서 각 노드가 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교한다.
        - 배열에 저장되어 있는 것보다 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우, 배열에 해당 노드의 거리를 업데이트 한다.
        - 배열에 해당 노드의 거리가 업데이트 된 경우, 우선순위 큐에 넣는다.
            - 결과적으로 너비 우선 탐색 방식과 유사하게, 첫 정점에 인접한 노드들을 순차적으로 방문하게 된다.
            - 만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리(루트)를 가진 (노드, 거리)의 경우에는 해당 노드와 인접한 노드간의  거리를 계산하지 않음
    3. 우선순위큐에 꺼낼 노드가 없을 때가지 2번과정 반복!