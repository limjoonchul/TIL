# 오늘 해야 할 일
* 운영체제 강의 듣고, 내용 정리
* 프로젝트 서버 배포 마지막 포스팅 예제 실습하기
* 알고리즘 강의 듣고 예제 문제 풀기

# 오늘 공부한 내용 및 느낀점
* 운영체제 강의 [시스템구조와 프로그램 실행 2번째 강의](https://core.ewha.ac.kr/publicview/C0101020140314151238067290?vmode=f) 를 이어서 들었다.
    * 아직까지는 전에 학원을 다니면서 들었던 내용이라 이해하는데 큰 어려움은 없고
    더 자세하게 이해할 수 있는 부분들이 있어서 좋은 것 같다.
* 프로젝트 서버 배포 [10. NginX 무중단 배포](https://velog.io/@swchoi0329/NGINX-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC) 를 진행했는데, 전의 내용이 에러가 났다.
    1. ProfileController Test가 에러나서 원인이 무엇인지 찾다가 main은 applicayion.yml로 하고 test는 application.properties로 되어있어서
    테스트를 돌리면 main의 yml것을 인식해서 test에 정의했던 대로 안됬던 것 같다. 그래서 test 것도 yml로 수정하니 해결되었다.
    
    2. 다른 문제는 h2에서 posts 테이블을 생성하는데 문제가 있었는데 datasource 설정을 추가해주니 해결되었다.
* 알고리즘 문제
    * [행렬곱셈](https://www.acmicpc.net/problem/2740)
        * 예전에 한번 연습으로 풀었던 적이 있어서 큰 문제없이 통과했다.
     
# 운영체제 내용 정리
## 서로 다른 입출력 명령어

- I/O를 수행하는 special instructure(일반적인 방법 메모리 어드레스와 입출력 디바이스 어드레스가 나눠져있는 상태)
    - CPU에서 실행하는 인스트력션에는 메모리에 접근하는 인스트럭션이 있고(로드 스토어 메모리에접근하는것을 이렇게 부름), 입출력 디바이스에 접근하는 인스트럭션이 있다.
    - 입출력도 주소가 있어서 특정 주소에 대해서  입출력에 접근하는 인스트럭션을 실행하면 그 디바이스에 접근하게 된다.
- Memory Mapped I/O
    - 입출력디바이스에 메모리주소를 매겨서 메모리 인스트럭션을 통해 입출력 디바이스에 접근하는 것을 말한다.
    - 입출력장치도 메모리 주소에 연장 주소를 붙인다음에 메모리주소가 100번지라고하면 메모리접근이고 1000번지라고하면 그건 디바이스 접근을 할수 있게 되어있는 형태이다.

## 저장 장치 계층 구조

레지스터 → 캐쉬 메모리 → 메인 메모리 → 하드디스크 → 옵티컬 디스크 → 마그테닉 테이프

- 처음부터 용량이 적지만 빠르고 가격이 비싸고 끝으로갈 수록 용량은 커지지만 느리고 가격이 싸다.
- 메인메모리까지 CPU에서 직접접근할 수 있는, 실질적으로 사용되는 영역이고 전원이 꺼지면 내용이 날라가는 휘발성 메모리이다.
- CPU가 인스트럭션을 처리하는데 있어서 한 클럭당 하나의 인스트럭션을 처리한다고 하면 메인메모리는 10~100 클럭당 처리를 하기 때문에 속도차이가 많이나서 중간에 캐시메모리를 두고 레지스터로 읽어들이는 것이다.
    - 캐시메모리는 메인메모리보다 용량이 작아서 모든 것을 담을 수 없기 때문에 필요한 데이터들만 그때그때 위로올려서 사용하는데 이것을 캐싱이라고 한다.
    - 캐싱의 목적은 재사용을 위해 사용한다 처음 사용한 데이터에 대해서는 어쩔수없이 하드디스크같은데서 가져와서 메인 메모리에 올려야하지만 한번 올라와 있는 데이터에 대해서는 빠르게 접근할 수 있다.
    - 캐시메모리가 용량이 작기 때문에 새로운 데이터를 필요로 할 때  기존것을 없애야하는데 어느것을 삭제할 것인가는 뒤에 메모리 관리에서 더 자세하 다룸!

## 프로그램의 실행 (메모리 Load)

- 프로그램은 실행파일 형태로 하드디스크에 저장된다. 실행파일을 실행시키면 메모리에 올라가서 프로세스가 된다.
- 바로 물리 메모리에 올라가지 않고 중간단계인 가상메모리를 거치게 된다.
- 프로그램을 실행시키면 해당 프로그램만의 독자적인 주소공간(Address space)이 형성된다. 아래 3가지 영역으로 형성됨!
    - code - cpu에서 실행할 기계어 코드
    - data - 변수, 전역변수같은 것들 자료구조를 담고있다.
    - stack - 코드가 함수로되어있어서 함수를 호출하거나 리턴할때 쌓았거나 꺼내가는 영역
- 커널은 컴퓨터를 부팅시키면 생겨서 전원이 꺼질 때까지 메모리에 항상 상주해있다. 그런데 프로그램들은 실행시키면 주소공간이 생겼다가 프로그램이 종료되면 사라지게된다.
- 이 주소공간을 물리메모리에 다 올려놓는게아니고 당장 필요한 부분만 물리메모리에 올리고 그렇지 않은건 올리지 않는다 낭비를 막기 위함
    - 가상메모리에서 필요한부분은 물리메모리에 올리고 그렇지 않은 부분은 하드 디스크의 swap area라는 공간에 내려 놓는다.
    - swap area 는 물리메모리 연장공간으로서 사용하는 공간을 말하고, 프로그램이 종료되거나, 컴퓨터가 꺼지게되면 사라지게된다.
    - 물리 메모리와 가상메모리 주소가 0번부터 ~ 끝까지 존재하는 형태를 가지고 있는데 가상메모리는 프로그램마다 각각 0번~끝까지 공간이생겨서 가상공간의 주소를 물리 메모리의 주소로 주소변환을 해줘야 한다. 이것을 해주는 운영체제가 하는것이 아니라 하드웨어 장치가 있다.(나중에 나옴)

## 커널 주소 공간의 내용

### CODE

- 커널 코드
    - 시스템 콜, 인터럽트 처리 코드
    - 자원 관리를 위한 코드
    - 편리한 서비스 제공을 위한 코드

### Data

- 운영체제가 사용하는 여러 자료구조가 정의되어 있다.
- 운영체제는 CPU, Memory, Disk를 관리하고 통제한다. 이런 하드웨어들을 관리하기 위해서 자료구조를 만들어서 관리를 하고 있다.
- 프로세스들을 관리하니깐 각 프로그램들이 독자적인주소공간을 가지고있지만 이런것들을 관리하기 위한 자료구조가필요하다 (어떤 프로그램이 cpu를 얼마나 썼는지, 메모리를얼마나줘야하는지등을 결정하기 위한 이런것들을 PCB라고 부른다.)
    - PCB(Process Control Block) - 프로그램이 돌아가면 프로그램을 관리하기 위한 자료구조가 운영체제 커널에 만들어진다.

### Stack

- 운영체제도 함수구조로 코드가짜여저서 함수를 호출하거나 리턴할 때 스택영역을 사용해야해서 커널 스택이라는게 존재한다.
- 운영체제의 코드는 여러 프로그램들이 요청에따라 불러서 사용 할 수 있다. 그래서 코드에서 함수호출을할 때 어떤 프로세스가 커널의 코드를 실행중인가에 따라서 사용자 프로그램마다 커널스택을 따로 두고 있다.(프로세스 A의 커널스택, 프로세스 B의 커널스택 등)

## 사용자 프로그램이 사용하는 함수

- 프로그램은 어떤 프로그래밍 언어로 짜든 함수형태로 만들어져 있다. 기계어로 번역되더라도 이 함수의 영역에 대한 정보가 유지되어있다. 저급언어로 되도라도 이 말이 쓰여지는 이유이다.
- 언어파일을 실행파일로 만들게되면 작성할때 사용한 함수들이 다 포함되어있다.
- 커널 함수는 프로세스 주소공간에 정의만 되어있고 호출하면 커널 주소공간으로 넘어가서 호출하게 된다.
- 보통 주소 점프라고 표현하는 것은 물리 메모리에서가 아니라 가상메모리 상에서 주소를 옮긴다는 의미이다.

### 함수(function)

- 사용자 정의 함수
    - 자신의 프로그램에서 정의한 함수
- 라이브러리 함수
    - 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수
    - 자신의 프로그램의 실행 파일에 포함되어 있다.
- 커널 함수
    - 운영체제 프로그램의 함수
    - 커널 함수의 호출 = 시스템 콜

## 프로그램의 실행

1. A라는 프로그램 시작
2.  A의 주소공간 코드 실행(User mode)- 자기가 정의한 함수를 호출해서 사용할 수도 있고 실행되다가 시스템 콜을 하게 되면
3. 커널의 주소공간 코드가 실행된다(커널모드)
4. 시스템 콜이 끝나면 다시 A의 주소공간으로 CPU가 넘어온다. 본인주소공간 코드를 실행 