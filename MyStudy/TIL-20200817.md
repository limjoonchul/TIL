# 상속 (Inheritance)
- 어떤 클래스의 모든 멤버 변수 및 메소드를 계승하여, 새로운 클래스를 생성하는 것
- 부모클래스로부터 상속을 받는 자식클래스는 부모클래스의 메소드나 멤버변수등 부모의 것을 가지고 있고, 추가적으로 자기의 것들도 가질 수 있다. ‘IS-A’관계라고도 한다.

# 클래스의 포함 관계
– 클래스를 조합해서 클래스를 만든다. Class Composition
- 상속하고 유사하지만, 한 클래스가 다른 클래스의 객체를 포함하는 관계
  ‘HAS-A’ 관계라고 표현된다. 

- 상속과 컴포지션의 차이 - 일치하냐, 보유하냐

# 메소드 재정의 method overriding
- override – 덮어씌운다, 해킹해서 뭔가 달라지게 한다. 기존에 있던걸 덮어씌워서 다른걸로 변형시키는 것. 다형성의 근간이 된다.
- 상속받는 자식클래스에 메소드를 재정의할 때 @Override를 적어주는 것이 관례이다, (필수x)

# super 키워드
- 호출할 때 this와 마찬가지로 첫줄에 써야함.
- this는 자신의 객체를 참조하고, super는 부모 객체를 참조한다.
- 부모의 부모는 참조할 수 없고, 바로 위의 부모만 참조할 수 있음.

- 멤버 변수명이 부모와 겹치면 재정의 하지만, 부모가 사라지는 것은 아니다.
- 부모클래스에 기본 생성자를 사용하는 경우에는 호출 안해줘도 됨. 파라미터 생성자일 때만
  호출해주면 된다.
- 부모클래스 생성자와 다르게 파라미터 변수명을 해줘야 한다.
- 부모 객체를 먼저 생성한다음, 자식객체가 생성됨.
- 자식클래스 생성자를 만들 때 부모 클래스 생성자도 같이 호출해줘야한다.
- 자식객체를 생성할 때마다 부모 객체를 따로따로 만들어서 가지고 있음.

# 제어자
- 자바 파일명과 같은 public class 클래스명이 꼭 있어야 한다.
- private – 같은 클래스에서만 사용가능, 내부 구현을 위해서만 사용한다.
- default – package라고도 한다 제어자명은 생략한다. 사용범위가 같은 패키지안에서 가능.
- protected – private와 비슷하게 사용이 되나, 상속한 경우 구현 시 접근이 필요할 때 사용.
            자식이면 다른 패키지여도 접근할 수가 있다, 하나의 자식외에는 못봄,
            부모의 부모는 건들 수 없음.
- public – 모든 곳에서 사용가능.
- 클래스는 public 과 default만 사용 가능하다.

# 다형성 
– 오버로딩에 의한 다형성, 오버라이딩에 의한 다형성(상속에 의한 다형성과 같다.)
- 부모 클래스 타입으로 자식 클래스 타입의 객체를 참조하는 특징.
- 자식 클래스의 메소드,변수 사용이 불가능하다.
- 반대로 자식 클래스 타입으로 부모 클래스 타입의 객체를 참조할 경우에는 문법적으로 오류는
  나지 않지만, 런타임시 에러가 발생한다.

- 멤버 변수의 재정의는 선언된 객체의 타입을 따른다. 문법적으로 본다.
- 메소드 오버라이딩은 메모리상의 객체 타입을 따른다. 실제 객체로 본다.
- virtual method call이 이루어진다.

# 공변 반환 타입 
- 오버라이딩이지만, 리턴 타입이 달라질 수 있다 여기서는 예외적으로 반환값이 달라진다.

# 추상클래스
- 일부 메소드가 구현되지 않고, 선언만 되어있는 클래스 
- 자식 클래스에서 이것을 반드시 구현하게끔 강제하는 것
- 생성자를 가질 수 있고, 일반 메소드도 가질 수 있다. 
- 생성자를 갖지만, 객체 생성이 불가능하다. 그런데 구현된 자식클래스의 객체는 받을 수 있다.

# 인터페이스
- 클래스가 사용되는 방식/접점만을 선언하는 클래스와 유사한 틀
- 아무런 구현이 되어 있지 않으며, 모든 메소드가 추상 메소드이다.
- 생성자를 가질 수 없고, 객체 생성을 할 수 없음.
- 자식 객체는 참조할 수 있으나 메소드와 변수는 사용 X
- 인터페이스명으로 클래스 메소드 호출이 가능하나, 
- 자식클래스명으로 클래스 메소드 호출 불가능.
- class가 아니고 interface 키워드를 사용한다.
- 멤버 변수는 항상 public static final 인데, 생략이 가능하다.
- 멤버 메소드도 항상 public abstract 이며, 생략이 가능하다.
- 클래스는 하나만 상속할 수 있으나, 인터페이스는 다중 상속이 가능하다.
- 클래스와 마찬가지로 제어자는 public,default 가능. 

JDK 1.8 버전 이후에 인터페이스 default 메소드를 구현할 수 있음.
인터페이스 철학과 맞지 않으나, 모든 자식 메소드에 동일하게 구현되어야 하는 메소드가 생긴 경우에 쉽게 기능을 추가하기 위해 만들어짐.
default메소드는 반드시 오버라이딩해야하는 것은 아니다.

# 열거형 enumeration
enum 키워드로 표현, ‘이넘’이라고 부른다.
enum은 이미 java.lang.Enum 클래스를 상속하고 있어서 다른 클래스를 상속하지 못함.
인터페이스 구현은 가능하다.
열거형 타입에는 열거형 상수와 null 값 할당 가능.
일종의 클래스 자료형으로 쓸 수 있고, 열거형 상수도 객체로 사용 가능.
생성자가 있을 수 있는데 앞에 private만 쓸 수 있고 생략 가능.
생성자는 String을 입력 받게 되어있는데, 각각 만들 때 각 객체에 값을 넣어줘야 함.


# 제네릭
- 클래스를 선언할 때에는 타입이 알려지지 않으며, 타입 파라미터를 사용한다.
- 생성자 있고, 객체 참조 가능. 인터페이스, 추상클래스 상속 가능.
- 정적 메소드도 사용이 가능하다. 다만, 클래스와 정적메소드의 타입파라미터를 갖게 하면 안된다.
- 생성자도 갖을 수 있음.
- 타입의 상속시 부모와 자식클래스의 타입을 맞추어 줘야 한다. 타입 파라미터도 모두 채워 주어야 한다. 부모클래스/인터페이스의 동일한 타입 파라미터를 넘겨줄 수 있다.
- static 멤버 변수, static 메소드는 타입파라미터를 사용할 수 없다.(왜냐하면, static은 객체가 생성되기 전에 메모리에 할당되는데 메모리에 할당되려면 타입이 있어야 하고, 타입 파라미터는 객체를 선언할 때 값이 넘어오기 때문에)
- new 키워드를 사용하여 객체를 참조할 수 없다.
- instanceof의 피연산자로 사용할 수 없다.

# 동적 바인딩 
- 메소드가 생길 때 자료형이랑 정의되어 있어서 기계가 동작하게 만들어지게 정상적인데, 자료형이 정해져있지 않아서 들어오는거에 따라 동작이 달라짐.
 실제로 런타임이 되지 않으면 컴파일 타임이 알 수 없음.( 컴파일 타임에는 동작이 완전히 정의가 되지 않음)

# wrapper 클래스
- 기본형 타입을 객체로 쓰기 위해 있는 클래스
- 기본형을 객체로 사용할 수 있게 하는 것을 - > Autoboxing
- 객체를 기본형으로 바꾸는 것을 -> Unboxing