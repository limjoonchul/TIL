# Servlet
* 서블릿을 이해하면 자바의 서버사이드쪽의 동작원리를 이해하는데 많은 도움이 된다.

## 이클립스에서 프로젝트 설정
### 이클립스에서 servlet-mapping하는 방법
  1. 프로젝트에서 src폴더를 우클릭해서 서블릿을 누른다
  2. 패키지명, 클래스명을 입력하고 next 누르면 클래스명(HelloServlet)이 name(HelloServlet)으로 되어있다.
  3. 클래스명을 소문자(hello)로 바꾼다.  
  4. URL Mappings의 /hello를 눌러서 원하는데로 바꾸고(/hello.do) 피니시 누르면 된다.
  그러면 web.xml의 servlet-mapping이 생겨져있다.
  ```xml
    <servlet>
      <servlet-name>hello</servlet-name>
      <servlet-class>hello.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello.do</url-pattern>
  ```
  * 브라우저가 /hello.do로 요청을 하면 hello.HelloServlet이 클래스를 찾아서 실행해라 라는 의미이다.

### 프로젝트를 서버에 등록하는 방법
1. 하단에 servers에서 tomcat에 오른쪽 키 add/remove를 누른다
2. 창이 뜨면 해당 파일을 눌러서 add를 클릭한다.
3. 오른쪽 configured로 add를 해주고 끝내면, 톰캣 서버가 이 프로젝트를 관리 해준다.
* servers창에서 톰캣을 누르면 프로젝트가 들어가 있는걸 확인할 수 있다. 
  * 단, 다이나믹 웹 프로젝트로 만들어져 있어야 등록 가능하다.

### 톰캣이란
* 톰캣은 아파치 재단에서 만든 자바로 되어있는 웹 어플리케이션 서버이다.
## Servlet
* 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램을 말한다.
* 웹 서버의 선응을 향상시키기 위해 사용되는 자바 클래스의 일종이다.
  * JSP와 비슷하지만 JSP는 HTML문서 안에 Java코드를 포함하고 Servlet은 Java코드안에 HTML을 포함한다.
* 서블릿은 자바 기술은 맞지만 톰캣 도움 없인 절대 실행할 수 없다.

### 서블릿의 특징
* 자바 클래스이고, ServletEngine에 의해서만 동작한다.
* Multi-Thread 
   * Servlet은 Multi-Thread로 동작하기 때문에 효율적이다.
   * 서블릿은 멀티스레드로 동작하기 때문에 웹에서 매우 효율적이다.
   * 서블릿을 멀티스레드로 동작시키는 것은 서블릿엔진이 하는 것이지 개발자가 하는 것이 아니다.
   
* 플랫폼 독립성
  * 서블릿은 자바로 작성되기 때문에 플랫폼에 무관하게 동일한 실행결과를 보인다.
* 서버 독립성
  * 서블릿은 웹 서버와 무관하게 실행이 된다. 서블릿 규칙에 맞게 작성을 해놓으면 톰캣서버에서 되던게 제우스 같은 다른 서버에서도 똑같이 실행이 된다.
* 플랫폼 독립성과 서버 독립성 이 두가지로 이식성이 좋다. 
* 확장성 - 외부 프레임워크라 유틸리티 클래스라던지 서블릿 프로그램을 더 빠르게 할 수 있다.

### 톰캣 서버 구동
* 톰캣 서버를 구동하면 톰캣 객체가 생성이 되고, 그 안에 포함 되어있는 서블릿 엔진도 생성이 된다.
* 서블릿 엔진은 web.xml을 로딩하고, 스레드 풀을 생성하고, 전체 라이프 사이클을 관리한다.

* 웹 기술은 개발자는 클래스만 만들 뿐이고 객체 생성해주는 건 개발자가가 아니다.
* 서블릿 엔진이 이 객체들을 생성해주는 코드를 실행하고 메소드를 호출하는 코드를 실행시킨다. 우리 눈엔 내부 동작이 안 보이게 동작한다.
* 서블릿 엔진이 생성될 때 web.xml이 로딩한다고 했는데 개발자가 개입할 수 있는건 hello.do라고 치면 hello.servlet이라는 객체를 생성하고
객체가 가지고 있는 메소드를 호출하도록 설정만 해두는 것이다.
#### 구동 흐름
* 서버 구동 버튼을 누르면 내부적으로 `new tomcat()`이 객체 생성이 되는 것이다.
* 톰캣 객체가 생성되면서 servers 창에 로그가 뜨는데 `StartServiceCatalina` 까지가 톰캣 서버가 구동 되었다는 의미이다.
  * 이 과정에서 에러가 안나면 된다.
* 톰캣 객체가 서블릿 엔진을 생성하는 코드를 가지고 있어서 서블릿 엔진이 생성이 된다.
* 서블릿 엔진 객체가 생성이 될 때 web.xml 파일이 전달 되는 것이다. 그래서 web.xml이 중요한 것이다. `new ServletEngine(web.xml)`
* 그 다음 클라이언트의 요청이 오면 web.xml에 매핑된 정보를 가지고 매핑해서 서블릿 객체를 생성하는 서블릿 라이프 사이클이 돌아가는 것이다.
밑에 서블릿 수행 흐름이 실행이 된다.

### 서블릿 수행 흐름

![서블릿수행흐름](/Java/documents/images/서블릿수행흐름.jpg)


1. 클라이언트에서 서블릿 요청(/hello.do)이 오면 서블릿 엔진은 요청된 서블릿이 메모리에 존재하는지 여부를 판단한다.
2. 요청한 서블릿이 메모리에 없으면 서블릿도 클래스니깐 web.xml에 매핑된 hello.servlet를 객체를 찾아서 생성하고 메모리에 로딩한다.
3. 생성자를 호출한다. 무조건 디폴트 생성자를 찾아서 메모리에 뜬다.(절대 매개변수가 있는 생성자를 인식하지 못한다.)
4. Init()를 호출한다. 디폴트 생성자가 호출이되서 서블릿 객체가 메모리에 뜨기 때문에 멤버번수를 단 한번 초기화할 때 필요하다.
5. 스레드 풀에서 스레드가 랜덤으로 튀어 나와서 할당이 된다.
6. 이 스레드가 서블릿 객체의 service()를 호출한다.(스레드는 run()를 호출하게 되어있는데 내부적으로 이 run()은 service()만 호출하게 되어있다.)
   * 메모리에 올라간 서블릿 객체를 스레드 풀에 있는 스레드들이 공유한다.
7. service() 메소드를 오버라이딩 하지 않으면 부모의 것이 호출이 되는데 이건 브라우저가 서버에 요청한 방식에 따라서
doGet(), doPost() 메소드를 호출하여서 메소드 동작이 이루어진다.
8. 그 다음 결과를 응답으로 클라이언트에게 보내준다.

* 처음 서블릿 요청이 들어오게 되면 위의 과정을 처음부터 수행하지만, 한 번 메모리가 할당이 되면 메모리에 존재하기 때문에
그 이후부터는 3번 과정부터 실행이 이루어져서 수행 속도가 빠르다.
* 그래서 어플리케이션을 서버에 올려서 배포를 할 때 한 번 동작을 시키고 배포를 한다 그래야 이용하는 클라이언트들이
모두 비슷한 실행 속도를 제공받을 수 있으니깐.

* 서버를 재 구동할 때 까지 서블릿 객체가 메모리에 띄워져 있다. 서버를 끊으면 서블릿 엔진이 죽어서 서블릿 객체를 메모리에서 회수하게 되어있다.
destroy() 메소드가 실행이되면서 자원들을 회수하고 종료됨.

### 서블릿 클래스 작성 규칙
* 외울 필요는 없고 이런 규칙으로 작성된다는 것만 알아두면 된다. IDE에서 서블릿으로 클래스를 생성하게 되면 자동으로 이 규칙에 맞게 생성해준다.
 1. HttpServlet 클래스를 상속해야 한다. - 서블릿으로 인지한다.
 2. public 클래스로 만들어야 한다. - 그래야 서블릿엔진에서 접근할 수 있으니깐.
 3. default 생성자가 있어야 한다. - 안 만들어도 자동 제공
 4. 요청 방식(method)에 따라 doGet이나 doPost를 재정의(Overriding)한다.
 5. 부모(HttpServlet) 클래스의 메소드를 재정의 하지 않으면 상속된다.